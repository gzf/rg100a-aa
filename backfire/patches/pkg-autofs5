Index: backfire/feeds/packages/utils/autofs/Makefile
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/Makefile
@@ -0,0 +1,84 @@
+#
+# Copyright (C) 2006-2010 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+
+include $(TOPDIR)/rules.mk
+
+PKG_NAME:=autofs
+PKG_VERSION:=5.0.6
+PKG_RELEASE:=1
+
+PKG_SOURCE:=$(PKG_NAME)-$(PKG_VERSION).tar.bz2
+PKG_SOURCE_URL:=http://www.kernel.org/pub/linux/daemons/autofs/v5
+PKG_MD5SUM:=44cea7f711e2290a0b50fddeda079705
+PKG_INSTALL:=1
+PKG_FIXUP:=autoreconf
+PKG_REMOVE_FILES:=
+
+AUTOFS_MODS := parse_sun.so \
+	mount_nfs4.so mount_nfs.so mount_generic.so mount_changer.so mount_bind.so mount_autofs.so mount_afs.so \
+	lookup_userhome.so lookup_program.so lookup_multi.so lookup_hosts.so lookup_files.so lookup_file.so lookup_dir.so
+
+AUTOFS_EXT2_MODS := mount_ext2.so mount_ext3.so mount_ext4.so
+
+include $(INCLUDE_DIR)/package.mk
+
+define Package/autofs5/common
+  SECTION:=utils
+  CATEGORY:=Utilities
+  SUBMENU:=Filesystem
+  TITLE:=Autofs Userspace Daemon
+  MAINTAINER:=Zhifeng Gu <guzhifeng1979@hotmail.com>
+  URL:=http://www.kernel.org/pub/linux/daemons/autofs/
+  DEPENDS+= +kmod-fs-autofs4 +libpthread
+endef
+
+define Package/autofs5
+  $(call Package/autofs5/common)
+  DEPENDS+= +kmod-fs-autofs4 +libpthread
+endef
+
+define Package/autofs5-mount-ext2
+  $(call Package/autofs5/common)
+  DEPENDS+= +autofs5 +e2fsprogs
+endef
+
+define Package/autofs5/conffiles
+/etc/config/autofs
+endef
+
+CONFIGURE_ARGS += --with-E2FSCK=/usr/sbin/e2fsck \
+				--with-E3FSCK=/usr/sbin/e2fsck \
+				--with-E4FSCK=/usr/sbin/e2fsck
+
+define Package/autofs5/install
+	$(INSTALL_DIR) $(1)/usr/sbin
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/sbin/automount $(1)/usr/sbin/
+	$(INSTALL_DIR) $(1)/usr/lib/autofs
+	for MOD in $(AUTOFS_MODS); do \
+		$(CP) $(PKG_INSTALL_DIR)/usr/lib/autofs/$$$$MOD $(1)/usr/lib/autofs/; \
+	done
+	$(INSTALL_DIR) $(1)/etc/config
+	$(INSTALL_DATA) ./files/autofs.conf $(1)/etc/config/autofs
+	$(INSTALL_DIR) $(1)/etc/init.d
+	$(INSTALL_BIN) ./files/autofs.init $(1)/etc/init.d/autofs
+	$(INSTALL_DIR) $(1)/etc/hotplug.d/block
+	$(INSTALL_DATA) ./files/50-autofs $(1)/etc/hotplug.d/block
+	$(INSTALL_DIR) $(1)/lib/functions/autofs
+	$(INSTALL_DATA) ./files/autofs.sh $(1)/lib/functions
+	$(INSTALL_BIN) ./files/direct.fstab $(1)/lib/functions/autofs
+	ln -sf /tmp/auto.master $(1)/etc/
+endef
+
+define Package/autofs5-mount-ext2/install
+	$(INSTALL_DIR) $(1)/usr/lib/autofs
+	for MOD in $(AUTOFS_EXT2_MODS); do \
+		$(CP) $(PKG_INSTALL_DIR)/usr/lib/autofs/$$$$MOD $(1)/usr/lib/autofs/; \
+	done
+endef
+
+$(eval $(call BuildPackage,autofs5))
+$(eval $(call BuildPackage,autofs5-mount-ext2))
Index: backfire/feeds/packages/utils/autofs/patches/100-autofs-5.0.6-fix-ipv6-name-for-lookup-fix.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/100-autofs-5.0.6-fix-ipv6-name-for-lookup-fix.patch
@@ -0,0 +1,79 @@
+autofs-5.0.6 - fix ipv6 name for lookup fix
+
+From: Ian Kent <ikent@redhat.com>
+
+Fix an error in the recent ipv6 name for lookup patch.
+
+Reported by Leonardo Chiquitto who provided a patch to resolve the
+problem. The patch below is a slightly modified version of his patch.
+---
+
+ CHANGELOG            |    4 ++++
+ modules/replicated.c |   13 ++++++++-----
+ 2 files changed, 12 insertions(+), 5 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index 849a38c..e5dfa83 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -1,3 +1,7 @@
++??/??/20?? autofs-5.0.7
++=======================
++- fix ipv6 name for lookup fix.
++
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+ - fix included map read fail handling.
+diff --git a/modules/replicated.c b/modules/replicated.c
+index 7f2b892..a10a817 100644
+--- a/modules/replicated.c
++++ b/modules/replicated.c
+@@ -1111,7 +1111,8 @@ static int add_host_addrs(struct host **list, const char *host,
+ 			  unsigned int weight, unsigned int options)
+ {
+ 	struct addrinfo hints, *ni, *this;
+-	char *name = strdup(host);
++	char *n_ptr;
++	char *name = n_ptr = strdup(host);
+ 	int len;
+ 	char buf[MAX_ERR_BUF];
+ 	int rr = 0;
+@@ -1125,15 +1126,17 @@ static int add_host_addrs(struct host **list, const char *host,
+ 	}
+ 	len = strlen(name);
+ 
+-	if (name[0] == '[' && name[--len] == ']')
++	if (name[0] == '[' && name[--len] == ']') {
+ 		name[len] = '\0';
++		name++;
++	}
+ 
+ 	memset(&hints, 0, sizeof(hints));
+ 	hints.ai_flags = AI_NUMERICHOST;
+ 	hints.ai_family = AF_UNSPEC;
+ 	hints.ai_socktype = SOCK_DGRAM;
+ 
+-	ret = getaddrinfo(name + 1, NULL, &hints, &ni);
++	ret = getaddrinfo(name, NULL, &hints, &ni);
+ 	if (ret)
+ 		goto try_name;
+ 
+@@ -1153,7 +1156,7 @@ try_name:
+ 	hints.ai_family = AF_UNSPEC;
+ 	hints.ai_socktype = SOCK_DGRAM;
+ 
+-	ret = getaddrinfo(name + 1, NULL, &hints, &ni);
++	ret = getaddrinfo(name, NULL, &hints, &ni);
+ 	if (ret) {
+ 		error(LOGOPT_ANY, "hostname lookup failed: %s",
+ 		      gai_strerror(ret));
+@@ -1172,7 +1175,7 @@ try_name:
+ 	}
+ 	freeaddrinfo(ni);
+ done:
+-	free(name);
++	free(n_ptr);
+ 	return ret;
+ }
+ 
Index: backfire/feeds/packages/utils/autofs/patches/101-autofs-5.0.6-improve-mount-location-error-reporting.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/101-autofs-5.0.6-improve-mount-location-error-reporting.patch
@@ -0,0 +1,117 @@
+autofs-5.0.6 - improve mount location error reporting
+
+From: Ian Kent <raven@themaw.net>
+
+Try and report a more sensible error when an invalid location is
+encountered.
+---
+
+ CHANGELOG           |    1 +
+ modules/parse_sun.c |   32 ++++++++++++++++++--------------
+ 2 files changed, 19 insertions(+), 14 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index e5dfa83..a178b74 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -1,6 +1,7 @@
+ ??/??/20?? autofs-5.0.7
+ =======================
+ - fix ipv6 name for lookup fix.
++- improve mount location error reporting.
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/modules/parse_sun.c b/modules/parse_sun.c
+index 3242e3b..021850d 100644
+--- a/modules/parse_sun.c
++++ b/modules/parse_sun.c
+@@ -853,7 +853,7 @@ add_offset_entry(struct autofs_point *ap, const char *name,
+ 	return ret;
+ }
+ 
+-static int validate_location(char *loc)
++static int validate_location(unsigned int logopt, char *loc)
+ {
+ 	char *ptr = loc;
+ 
+@@ -867,14 +867,22 @@ static int validate_location(char *loc)
+ 	 * and "@" in the host name part and ipv6 addresses that
+ 	 * have ":", "[" and "]".
+ 	 */
+-	if (check_colon(ptr)) {
++	if (!check_colon(ptr)) {
++		error(logopt,
++		      "expected colon delimeter not found in location %s",
++		      loc);
++		return 0;
++	} else {
+ 		while (*ptr && strncmp(ptr, ":/", 2)) {
+ 			if (!(isalnum(*ptr) ||
+ 			    *ptr == '-' || *ptr == '.' || *ptr == '_' ||
+ 			    *ptr == ',' || *ptr == '(' || *ptr == ')' ||
+ 			    *ptr == '#' || *ptr == '@' || *ptr == ':' ||
+-			    *ptr == '[' || *ptr == ']'))
++			    *ptr == '[' || *ptr == ']')) {
++				error(logopt, "invalid character \"%c\" "
++				      "found in location %s", *ptr, loc);
+ 				return 0;
++			}
+ 			ptr++;
+ 		}
+ 
+@@ -883,8 +891,10 @@ static int validate_location(char *loc)
+ 	}
+ 
+ 	/* Must always be something following */
+-	if (!*ptr)
++	if (!*ptr) {
++		error(logopt, "invalid location %s", loc);
+ 		return 0;
++	}
+ 
+ 	return 1;
+ }
+@@ -951,8 +961,7 @@ static int parse_mapent(const char *ent, char *g_options, char **options, char *
+ 		return 0;
+ 	}
+ 
+-	if (!validate_location(loc)) {
+-		warn(logopt, MODPREFIX "invalid location %s", loc);
++	if (!validate_location(logopt, loc)) {
+ 		free(myoptions);
+ 		free(loc);
+ 		return 0;
+@@ -985,9 +994,7 @@ static int parse_mapent(const char *ent, char *g_options, char **options, char *
+ 			return 0;
+ 		}
+ 
+-		if (!validate_location(ent_chunk)) {
+-			warn(logopt,
+-			      MODPREFIX "invalid location %s", ent_chunk);
++		if (!validate_location(logopt, ent_chunk)) {
+ 			free(ent_chunk);
+ 			free(myoptions);
+ 			free(loc);
+@@ -1688,8 +1695,7 @@ int parse_mount(struct autofs_point *ap, const char *name,
+ 			return 1;
+ 		}
+ 
+-		if (!validate_location(loc)) {
+-			warn(ap->logopt, MODPREFIX "invalid location %s", loc);
++		if (!validate_location(ap->logopt, loc)) {
+ 			free(loc);
+ 			free(options);
+ 			return 1;
+@@ -1714,9 +1720,7 @@ int parse_mount(struct autofs_point *ap, const char *name,
+ 				return 1;
+ 			}
+ 
+-			if (!validate_location(ent)) {
+-				warn(ap->logopt,
+-				     MODPREFIX "invalid location %s", loc);
++			if (!validate_location(ap->logopt, ent)) {
+ 				free(ent);
+ 				free(loc);
+ 				free(options);
Index: backfire/feeds/packages/utils/autofs/patches/102-autofs-5.0.6-fix-paged-query-more-results-check.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/102-autofs-5.0.6-fix-paged-query-more-results-check.patch
@@ -0,0 +1,87 @@
+autofs-5.0.6 - fix paged query more results check
+
+From: Ian Kent <raven@themaw.net>
+
+When getting paged results from an LDAP server the server returns an
+opaque cookie (of type berval) that is used to retrieve the next page.
+The criteria for deciding if there are more pages is that the berval
+value is non-null and has a non-zero length.
+
+To determine if the berval value has non-zero length autofs checks the
+strlen() of the value but on ppc64 and s390x this can return 0 even if
+the value has non-zero length causing a premature termination of the
+query.
+
+Fix this by also checking the berval length field.
+Also make sure we free the opaque cookie when the query is finished.
+---
+
+ CHANGELOG             |    1 +
+ modules/lookup_ldap.c |   13 ++++++++++++-
+ 2 files changed, 13 insertions(+), 1 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index a178b74..884a9ae 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -2,6 +2,7 @@
+ =======================
+ - fix ipv6 name for lookup fix.
+ - improve mount location error reporting.
++- fix paged query more results check.
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/modules/lookup_ldap.c b/modules/lookup_ldap.c
+index 719fed1..a25050a 100644
+--- a/modules/lookup_ldap.c
++++ b/modules/lookup_ldap.c
+@@ -2041,7 +2041,8 @@ do_paged:
+ 	rv = ldap_parse_page_control(sp->ldap,
+ 				     returnedControls, &sp->totalCount,
+ 				     &sp->cookie);
+-	if (sp->cookie && sp->cookie->bv_val && strlen(sp->cookie->bv_val))
++	if (sp->cookie && sp->cookie->bv_val &&
++	    (strlen(sp->cookie->bv_val) || sp->cookie->bv_len))
+ 		sp->morePages = TRUE;
+ 	else
+ 		sp->morePages = FALSE;
+@@ -2382,6 +2383,10 @@ static int read_one_map(struct autofs_point *ap,
+ 		    rv == LDAP_SIZELIMIT_EXCEEDED) {
+ 			if (sp.result)
+ 				ldap_msgfree(sp.result);
++			if (sp.cookie) {
++				ber_bvfree(sp.cookie);
++				sp.cookie = NULL;
++			}
+ 			sp.pageSize = sp.pageSize / 2;
+ 			if (sp.pageSize < 5) {
+ 				debug(ap->logopt, MODPREFIX
+@@ -2397,6 +2402,8 @@ static int read_one_map(struct autofs_point *ap,
+ 		if (rv != LDAP_SUCCESS || !sp.result) {
+ 			unbind_ldap_connection(ap->logopt, sp.ldap, ctxt);
+ 			*result_ldap = rv;
++			if (sp.cookie)
++				ber_bvfree(sp.cookie);
+ 			free(sp.query);
+ 			return NSS_STATUS_UNAVAIL;
+ 		}
+@@ -2406,6 +2413,8 @@ static int read_one_map(struct autofs_point *ap,
+ 			ldap_msgfree(sp.result);
+ 			unbind_ldap_connection(ap->logopt, sp.ldap, ctxt);
+ 			*result_ldap = rv;
++			if (sp.cookie)
++				ber_bvfree(sp.cookie);
+ 			free(sp.query);
+ 			return NSS_STATUS_NOTFOUND;
+ 		}
+@@ -2417,6 +2426,8 @@ static int read_one_map(struct autofs_point *ap,
+ 	unbind_ldap_connection(ap->logopt, sp.ldap, ctxt);
+ 
+ 	source->age = age;
++	if (sp.cookie)
++		ber_bvfree(sp.cookie);
+ 	free(sp.query);
+ 
+ 	return NSS_STATUS_SUCCESS;
Index: backfire/feeds/packages/utils/autofs/patches/103-autofs-5.0.6-fix-dumpmaps-not-reading-maps.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/103-autofs-5.0.6-fix-dumpmaps-not-reading-maps.patch
@@ -0,0 +1,47 @@
+autofs-5.0.6 - fix dumpmaps not reading maps
+
+From: Ian Kent <raven@themaw.net>
+
+The lookup modules won't read any indirect map entries (other than those
+in a file map) unless unless the browse option is set. In order to list
+the entries when tyhe dumpmap option is given the browse option needs to
+be set.
+---
+
+ CHANGELOG    |    1 +
+ lib/master.c |    9 +++++++++
+ 2 files changed, 10 insertions(+), 0 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index 884a9ae..946a196 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -3,6 +3,7 @@
+ - fix ipv6 name for lookup fix.
+ - improve mount location error reporting.
+ - fix paged query more results check.
++- fix dumpmaps not reading maps.
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/lib/master.c b/lib/master.c
+index 153a38b..6c89e1d 100644
+--- a/lib/master.c
++++ b/lib/master.c
+@@ -1283,6 +1283,15 @@ int master_show_mounts(struct master *master)
+ 		printf("\nMount point: %s\n", ap->path);
+ 		printf("\nsource(s):\n");
+ 
++		/*
++		 * Ensure we actually read indirect map entries so we can
++		 * list them. The map reads won't read any indirect map
++		 * entries (other than those in a file map) unless the
++		 * browse option is set.
++		 */
++		if (ap->type == LKP_INDIRECT)
++			ap->flags |= MOUNT_FLAG_GHOST;
++
+ 		/* Read the map content into the cache */
+ 		if (lookup_nss_read_map(ap, NULL, now))
+ 			lookup_prune_cache(ap, now);
Index: backfire/feeds/packages/utils/autofs/patches/104-autofs-5.0.6-fix-result-null-check-in-read_one_map.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/104-autofs-5.0.6-fix-result-null-check-in-read_one_map.patch
@@ -0,0 +1,58 @@
+autofs-5.0.6 - fix result null check in read_one_map()
+
+From: Ian Kent <ikent@redhat.com>
+
+Fix the check and reset to NULL of the LDAP library allocated result
+within the loop to fetch paged query values.
+---
+
+ CHANGELOG             |    1 +
+ modules/lookup_ldap.c |    7 ++++++-
+ 2 files changed, 7 insertions(+), 1 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index 946a196..66b804f 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -4,6 +4,7 @@
+ - improve mount location error reporting.
+ - fix paged query more results check.
+ - fix dumpmaps not reading maps.
++- fix result null check in read_one_map().
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/modules/lookup_ldap.c b/modules/lookup_ldap.c
+index a25050a..22ff355 100644
+--- a/modules/lookup_ldap.c
++++ b/modules/lookup_ldap.c
+@@ -2381,8 +2381,10 @@ static int read_one_map(struct autofs_point *ap,
+ 
+ 		if (rv == LDAP_ADMINLIMIT_EXCEEDED ||
+ 		    rv == LDAP_SIZELIMIT_EXCEEDED) {
+-			if (sp.result)
++			if (sp.result) {
+ 				ldap_msgfree(sp.result);
++				sp.result = NULL;
++			}
+ 			if (sp.cookie) {
+ 				ber_bvfree(sp.cookie);
+ 				sp.cookie = NULL;
+@@ -2402,6 +2404,8 @@ static int read_one_map(struct autofs_point *ap,
+ 		if (rv != LDAP_SUCCESS || !sp.result) {
+ 			unbind_ldap_connection(ap->logopt, sp.ldap, ctxt);
+ 			*result_ldap = rv;
++			if (sp.result)
++				ldap_msgfree(sp.result);
+ 			if (sp.cookie)
+ 				ber_bvfree(sp.cookie);
+ 			free(sp.query);
+@@ -2419,6 +2423,7 @@ static int read_one_map(struct autofs_point *ap,
+ 			return NSS_STATUS_NOTFOUND;
+ 		}
+ 		ldap_msgfree(sp.result);
++		sp.result = NULL;
+ 	} while (sp.morePages == TRUE);
+ 
+ 	debug(ap->logopt, MODPREFIX "done updating map");
Index: backfire/feeds/packages/utils/autofs/patches/105-autofs-5.0.6-fix-LDAP-result-leaks-on-error-paths.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/105-autofs-5.0.6-fix-LDAP-result-leaks-on-error-paths.patch
@@ -0,0 +1,56 @@
+autofs-5.0.6 - Fix LDAP result leaks on error paths
+
+From: Leonardo Chiquitto <leonardo.lists@gmail.com>
+
+According to ldap_search_s(3), the result structure must be freed
+with ldap_msgfree() even when the search function returned failure.
+---
+
+ CHANGELOG             |    1 +
+ modules/lookup_ldap.c |    6 ++++++
+ 2 files changed, 7 insertions(+), 0 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index 66b804f..dc91c25 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -5,6 +5,7 @@
+ - fix paged query more results check.
+ - fix dumpmaps not reading maps.
+ - fix result null check in read_one_map().
++- fix LDAP result leaks on error paths.
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/modules/lookup_ldap.c b/modules/lookup_ldap.c
+index 22ff355..29323b2 100644
+--- a/modules/lookup_ldap.c
++++ b/modules/lookup_ldap.c
+@@ -347,6 +347,8 @@ static int get_query_dn(unsigned logopt, LDAP *ldap, struct lookup_context *ctxt
+ 			error(logopt,
+ 			      MODPREFIX "query failed for %s: %s",
+ 			      query, ldap_err2string(rv));
++			if (result)
++				ldap_msgfree(result);
+ 			free(query);
+ 			return 0;
+ 		}
+@@ -1573,6 +1575,8 @@ int lookup_read_master(struct master *master, time_t age, void *context)
+ 		error(logopt, MODPREFIX "query failed for %s: %s",
+ 		      query, ldap_err2string(rv));
+ 		unbind_ldap_connection(logging, ldap, ctxt);
++		if (result)
++			ldap_msgfree(result);
+ 		free(query);
+ 		return NSS_STATUS_NOTFOUND;
+ 	}
+@@ -2586,6 +2590,8 @@ static int lookup_one(struct autofs_point *ap,
+ 	if ((rv != LDAP_SUCCESS) || !result) {
+ 		crit(ap->logopt, MODPREFIX "query failed for %s", query);
+ 		unbind_ldap_connection(ap->logopt, ldap, ctxt);
++		if (result)
++			ldap_msgfree(result);
+ 		free(query);
+ 		return CHE_FAIL;
+ 	}
Index: backfire/feeds/packages/utils/autofs/patches/106-autofs-5.0.6-fix-fix-LDAP-result-leaks-on-error-paths.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/106-autofs-5.0.6-fix-fix-LDAP-result-leaks-on-error-paths.patch
@@ -0,0 +1,57 @@
+autofs-5.0.6 - fix fix LDAP result leaks on error paths
+
+From: Ian Kent <raven@themaw.net>
+
+The previous patch with which ensured that the result struture returned
+from ldap_search_s(3) was freed could sometimes lead to a segmentation
+fault because the local variable used was not initialized before use.
+---
+
+ CHANGELOG             |    1 +
+ modules/lookup_ldap.c |    6 +++---
+ 2 files changed, 4 insertions(+), 3 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index dc91c25..d7c20ca 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -6,6 +6,7 @@
+ - fix dumpmaps not reading maps.
+ - fix result null check in read_one_map().
+ - fix LDAP result leaks on error paths.
++- fix fix LDAP result leaks on error paths.
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/modules/lookup_ldap.c b/modules/lookup_ldap.c
+index 29323b2..d8e93e7 100644
+--- a/modules/lookup_ldap.c
++++ b/modules/lookup_ldap.c
+@@ -280,7 +280,7 @@ static int get_query_dn(unsigned logopt, LDAP *ldap, struct lookup_context *ctxt
+ {
+ 	char buf[MAX_ERR_BUF];
+ 	char *query, *dn, *qdn;
+-	LDAPMessage *result, *e;
++	LDAPMessage *result = NULL, *e;
+ 	struct ldap_searchdn *sdns = NULL;
+ 	char *attrs[2];
+ 	struct berval **value;
+@@ -1529,7 +1529,7 @@ int lookup_read_master(struct master *master, time_t age, void *context)
+ 	char buf[MAX_ERR_BUF];
+ 	char parse_buf[PARSE_MAX_BUF];
+ 	char *query;
+-	LDAPMessage *result, *e;
++	LDAPMessage *result = NULL, *e;
+ 	char *class, *info, *entry;
+ 	char **keyValue = NULL;
+ 	char **values = NULL;
+@@ -2475,7 +2475,7 @@ static int lookup_one(struct autofs_point *ap,
+ 	char buf[MAX_ERR_BUF];
+ 	time_t age = time(NULL);
+ 	char *query;
+-	LDAPMessage *result, *e;
++	LDAPMessage *result = NULL, *e;
+ 	char *class, *info, *entry;
+ 	char *enc_key1, *enc_key2;
+ 	int enc_len1 = 0, enc_len2 = 0;
Index: backfire/feeds/packages/utils/autofs/patches/107-autofs-5.0.6-code-analysis-fixes-1.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/107-autofs-5.0.6-code-analysis-fixes-1.patch
@@ -0,0 +1,101 @@
+autofs-5.0.6 - code analysis fixes 1
+
+From: Ian Kent <ikent@redhat.com>
+
+Code analysis defect fixes, installment 1.
+
+- fix signed usage of unsigned variable in do_srv_query().
+- make NULL check handling of variable dcs explicit in get_dc_list().
+  - adding an explicit NULL check for variable dcs gaurds against
+    future changes in get_srv_rrs() returning success while not
+    clearing the dcs variable.
+  - makes it explict for readers why we don't need to check for NULL
+    before free later in the loop.
+- fix typo in do_reconnect()
+  - uri is never set now and, at this point, we need to try to connect
+    to the last server uri (ctxt->uri->uri) which is set in find_server()
+    when ctxt->uri is NULL.
+---
+
+ CHANGELOG             |    1 +
+ modules/dclist.c      |   11 +++++------
+ modules/lookup_ldap.c |    3 +--
+ 3 files changed, 7 insertions(+), 8 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index d7c20ca..3aa5f3d 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -7,6 +7,7 @@
+ - fix result null check in read_one_map().
+ - fix LDAP result leaks on error paths.
+ - fix fix LDAP result leaks on error paths.
++- code analysis fixes part 1.
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/modules/dclist.c b/modules/dclist.c
+index aeb107f..d16b913 100644
+--- a/modules/dclist.c
++++ b/modules/dclist.c
+@@ -69,7 +69,7 @@ static void dclist_mutex_unlock(void)
+ 
+ static int do_srv_query(unsigned int logopt, char *name, u_char **packet)
+ {
+-	unsigned int len = PACKETSZ;
++	int len = PACKETSZ;
+ 	unsigned int last_len = len;
+ 	char ebuf[MAX_ERR_BUF];
+ 	u_char *buf;
+@@ -500,7 +500,8 @@ struct dclist *get_dc_list(unsigned int logopt, const char *uri)
+ 		}
+ 
+ 		dclist_mutex_lock();
+-		if (!get_srv_rrs(logopt, request, &dcs, &numdcs)) {
++		ret = get_srv_rrs(logopt, request, &dcs, &numdcs);
++		if (!ret | !dcs) {
+ 			error(logopt,
+ 			      "DNS SRV query failed for domain %s", domain);
+ 			dclist_mutex_unlock();
+@@ -526,8 +527,7 @@ struct dclist *get_dc_list(unsigned int logopt, const char *uri)
+ 		if (!tmp) {
+ 			char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
+ 			error(logopt, "realloc: %s", estr);
+-			if (dcs)
+-				free_srv_rrs(dcs, numdcs);
++			free_srv_rrs(dcs, numdcs);
+ 			goto out_error;
+ 		}
+ 
+@@ -548,8 +548,7 @@ struct dclist *get_dc_list(unsigned int logopt, const char *uri)
+ 				if (ret > 6) {
+ 					error(logopt,
+ 					      "invalid port: %u", dcs[i].port);
+-					if (dcs)
+-						free_srv_rrs(dcs, numdcs);
++					free_srv_rrs(dcs, numdcs);
+ 					goto out_error;
+ 				}
+ 				strcat(tmp, port);
+diff --git a/modules/lookup_ldap.c b/modules/lookup_ldap.c
+index d8e93e7..b6875fe 100644
+--- a/modules/lookup_ldap.c
++++ b/modules/lookup_ldap.c
+@@ -736,7 +736,6 @@ static LDAP *find_server(unsigned logopt, struct lookup_context *ctxt)
+ static LDAP *do_reconnect(unsigned logopt, struct lookup_context *ctxt)
+ {
+ 	LDAP *ldap = NULL;
+-	char *uri;
+ 
+ 	if (ctxt->server || !ctxt->uris) {
+ 		ldap = do_connect(logopt, ctxt->server, ctxt);
+@@ -780,7 +779,7 @@ static LDAP *do_reconnect(unsigned logopt, struct lookup_context *ctxt)
+ 	 */
+ 	if (!ldap) {
+ 		autofs_sasl_dispose(ctxt);
+-		ldap = connect_to_server(logopt, uri, ctxt);
++		ldap = connect_to_server(logopt, ctxt->uri->uri, ctxt);
+ 	}
+ #endif
+ 	if (ldap)
Index: backfire/feeds/packages/utils/autofs/patches/108-autofs-5.0.6-fix-not-bind-mounting-local-filesystem.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/108-autofs-5.0.6-fix-not-bind-mounting-local-filesystem.patch
@@ -0,0 +1,56 @@
+autofs-5.0.6 - fix not bind mounting local filesystem
+
+From: Ian Kent <ikent@redhat.com>
+
+When the --random-multimount-selection (-r) option is used automount(8)
+won't bind mount a local filesystem. If the filesystem that has been
+requested is local it should always be used.
+---
+
+ CHANGELOG            |    1 +
+ modules/replicated.c |   12 +++++++-----
+ 2 files changed, 8 insertions(+), 5 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index 3aa5f3d..13b4bf4 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -8,6 +8,7 @@
+ - fix LDAP result leaks on error paths.
+ - fix fix LDAP result leaks on error paths.
+ - code analysis fixes part 1.
++- fix not bind mounting local filesystem.
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/modules/replicated.c b/modules/replicated.c
+index a10a817..eee1a06 100644
+--- a/modules/replicated.c
++++ b/modules/replicated.c
+@@ -1068,18 +1068,20 @@ static int add_new_host(struct host **list,
+ 	 * We can't use PROXIMITY_LOCAL or we won't perform an RPC ping
+ 	 * to remove hosts that may be down.
+ 	 */
+-	if (options & MOUNT_FLAG_RANDOM_SELECT)
++	if (!host_addr)
+ 		prx = PROXIMITY_SUBNET;
+ 	else {
+ 		prx = get_proximity(host_addr->ai_addr);
+ 		/*
+ 		 * If we want the weight to be the determining factor
+-		 * when selecting a host then all hosts must have the
+-		 * same proximity. However, if this is the local machine
+-		 * it should always be used since it is certainly available.
++		 * when selecting a host, or we are using random selection,
++		 * then all hosts must have the same proximity. However,
++		 * if this is the local machine it should always be used
++		 * since it is certainly available.
+ 		 */
+ 		if (prx != PROXIMITY_LOCAL &&
+-		   (options & MOUNT_FLAG_USE_WEIGHT_ONLY))
++		   (options & (MOUNT_FLAG_USE_WEIGHT_ONLY |
++			       MOUNT_FLAG_RANDOM_SELECT)))
+ 			prx = PROXIMITY_SUBNET;
+ 	}
+ 
Index: backfire/feeds/packages/utils/autofs/patches/109-autofs-5.0.6-add-dir-map-type.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/109-autofs-5.0.6-add-dir-map-type.patch
@@ -0,0 +1,393 @@
+autofs-5.0.5 - dir map-type patch v2
+
+From: Masatake YAMATO <yamato@redhat.com>
+
+This is the second post of "dir map-type" patch.
+
+Changes since last post:
+
+	- Don't use auto. as prefix for included map.
+          Use .autofs suffix instead. Suggested by Steve Linn.
+
+	- Use scandir instead of using opendir/readdir/closedir.
+
+
+What is dir map-type?
+
+
+`dir' map-type is for including files under a directory into master
+map.
+`file' map-type can be used for including a file with + notation like:
+
+       +/etc/auto.mine
+
+in auto.master. However, for specifying a new file to be included you
+have to edit auto.master file. Editing is also needed when you want to
+remove the included file. When you have to do this with your shell
+script you may have to use sed or awk.
+
+`dir' map-type permits you adding new master map entries with cp
+command and removing the entries with rm command. `dir' map-type is
+inspired from /etc/httpd/conf.d and /etc/modprobe.d.
+
+`dir' map-type can be used for included files under a directory
+(e.g. /etc/auto.master.d) with + notation like:
+
+      +dir:/etc/auto.master.d
+
+in auto.master. With this notation /etc/auto.master.d/*.autofs files
+are included except a file which name is started with ".".  With the
+name of the file you can control whether a file under the directory is
+included or not: the file which name ends with ".autofs" is included.
+
+
+Signed-off-by: Masatake YAMATO <yamato@redhat.com>
+---
+
+ CHANGELOG            |    1 
+ autofs.spec          |    2 
+ daemon/lookup.c      |    3 -
+ man/auto.master.5.in |   10 ++
+ modules/Makefile     |    6 +
+ modules/lookup_dir.c |  219 ++++++++++++++++++++++++++++++++++++++++++++++++++
+ samples/auto.master  |    4 +
+ 7 files changed, 240 insertions(+), 5 deletions(-)
+ create mode 100644 modules/lookup_dir.c
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index 13b4bf4..1e6edd1 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -9,6 +9,7 @@
+ - fix fix LDAP result leaks on error paths.
+ - code analysis fixes part 1.
+ - fix not bind mounting local filesystem.
++- add "dir" map-type.
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/autofs.spec b/autofs.spec
+index 91d4f8b..82edd1e 100644
+--- a/autofs.spec
++++ b/autofs.spec
+@@ -67,6 +67,7 @@ mkdir -p -m755 $RPM_BUILD_ROOT%{_sbindir}
+ mkdir -p -m755 $RPM_BUILD_ROOT%{_libdir}/autofs
+ mkdir -p -m755 $RPM_BUILD_ROOT%{_mandir}/{man5,man8}
+ mkdir -p -m755 $RPM_BUILD_ROOT/etc/sysconfig
++mkdir -p -m755 $RPM_BUILD_ROOT/etc/auto.master.d
+ 
+ make install mandir=%{_mandir} initdir=/etc/rc.d/init.d INSTALLROOT=$RPM_BUILD_ROOT
+ make -C redhat
+@@ -104,6 +105,7 @@ fi
+ %dir %{_libdir}/autofs
+ %{_libdir}/autofs/*
+ %{_mandir}/*/*
++%dir /etc/auto.master.d
+ 
+ %changelog
+ * Tue Jun 3 2011 Ian Kent <raven@themaw.net>
+diff --git a/daemon/lookup.c b/daemon/lookup.c
+index 958d8cc..098588c 100644
+--- a/daemon/lookup.c
++++ b/daemon/lookup.c
+@@ -176,7 +176,8 @@ int lookup_nss_read_master(struct master *master, time_t age)
+ 			    !strncmp(name, "nis:", 4) ||
+ 			    !strncmp(name, "nisplus:", 8) ||
+ 			    !strncmp(name, "ldap:", 5) ||
+-			    !strncmp(name, "ldaps:", 6)) {
++			    !strncmp(name, "ldaps:", 6) ||
++			    !strncmp(name, "dir:", 4)) {
+ 				strncpy(source, name, tmp - name);
+ 
+ 				/*
+diff --git a/man/auto.master.5.in b/man/auto.master.5.in
+index de692d2..fff9943 100644
+--- a/man/auto.master.5.in
++++ b/man/auto.master.5.in
+@@ -107,6 +107,14 @@ appropriate certificate must be configured in the LDAP client.
+ .B multi
+ This map type allows the specification of multiple maps separated
+ by "--". These maps are searched in order to resolve key lookups.
++.TP
++.B dir
++This map type can be used at
++.BR +
++master map including notation. The contents of files under given directory are included
++to the master map. The name of file to be included must be ended with ".autofs". A file
++will be ignored if its name is not ended with the suffix. In addition a dot file, a file
++which name is started with "." is also ignored.
+ .RE
+ .TP
+ \fBformat\fP
+@@ -118,7 +126,7 @@ left unspecified, it defaults to \fBsun\fP for all map types except
+ .TP
+ \fBmap\fP
+ Name of the map to use.  This is an absolute UNIX pathname
+-for maps of types \fBfile\fP or \fBprogram\fP, and the name of a database
++for maps of types \fBfile\fP, \fBdir\fP, or \fBprogram\fP, and the name of a database
+ in the case for maps of type \fByp\fP, \fBnisplus\fP, or \fBhesiod\fP or
+ the \fBdn\fP of an LDAP entry for maps of type \fBldap\fP.
+ .TP
+diff --git a/modules/Makefile b/modules/Makefile
+index a35c0a5..6090127 100644
+--- a/modules/Makefile
++++ b/modules/Makefile
+@@ -5,14 +5,14 @@
+ -include ../Makefile.conf
+ include ../Makefile.rules
+ 
+-SRCS :=	lookup_yp.c  lookup_file.c  lookup_program.c  lookup_userhome.c \
+-	lookup_multi.c lookup_hosts.c \
++SRCS :=	lookup_yp.c  lookup_file.c lookup_program.c  lookup_userhome.c \
++	lookup_multi.c lookup_hosts.c lookup_dir.c \
+ 	parse_sun.c    \
+ 	mount_generic.c  mount_nfs.c  mount_afs.c  mount_autofs.c \
+ 	mount_changer.c  mount_bind.c
+ 
+ MODS :=	lookup_yp.so lookup_file.so lookup_program.so lookup_userhome.so \
+-	lookup_multi.so lookup_hosts.so \
++	lookup_multi.so lookup_hosts.so lookup_dir.so \
+ 	parse_sun.so \
+ 	mount_generic.so mount_nfs.so mount_afs.so mount_autofs.so \
+ 	mount_changer.so mount_bind.so
+diff --git a/modules/lookup_dir.c b/modules/lookup_dir.c
+new file mode 100644
+index 0000000..658cc29
+--- /dev/null
++++ b/modules/lookup_dir.c
+@@ -0,0 +1,219 @@
++/* ----------------------------------------------------------------------- *
++ *
++ *  lookup_dir.c - module for including master files in a directory.
++ *
++ * Copyright 2011 Red Hat, Inc. All rights reserved.
++ * Copyright 2011 Masatake YAMATO <yamato@redhat.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation, Inc., 675 Mass Ave, Cambridge MA 02139,
++ * USA; either version 2 of the License, or (at your option) any later
++ * version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * ----------------------------------------------------------------------- */
++
++#include <stdio.h>
++#include <malloc.h>
++#include <pwd.h>
++#include <string.h>
++#include <sys/param.h>
++#include <sys/types.h>
++#include <sys/stat.h>
++#include <dirent.h>
++
++
++#define MODULE_LOOKUP
++#include "automount.h"
++#include "nsswitch.h"
++
++#define MODPREFIX "lookup(dir): "
++
++#define MAX_INCLUDE_DEPTH	16
++
++#define AUTOFS_DIR_EXT ".autofs"
++#define AUTOFS_DIR_EXTSIZ (sizeof(AUTOFS_DIR_EXT) - 1)
++
++struct lookup_context {
++  const char *mapname;
++};
++
++int lookup_version = AUTOFS_LOOKUP_VERSION;	/* Required by protocol */
++
++
++int lookup_init(const char *mapfmt, int argc, const char *const *argv, void **context)
++{
++	struct lookup_context *ctxt;
++	char buf[MAX_ERR_BUF];
++	struct stat st;
++
++	*context = NULL;
++	ctxt = malloc(sizeof(struct lookup_context));
++	if (!ctxt) {
++		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
++		logerr(MODPREFIX "malloc: %s", estr);
++		return 1;
++	}
++
++	if (argc < 1) {
++		free(ctxt);
++		logerr(MODPREFIX "No map name");
++		return 1;
++	}
++
++	ctxt->mapname = argv[0];
++
++	if (ctxt->mapname[0] != '/') {
++		free(ctxt);
++		logmsg(MODPREFIX
++		     "dir map %s is not an absolute pathname", argv[0]);
++		return 1;
++	}
++
++	if (access(ctxt->mapname, R_OK)) {
++		free(ctxt);
++		warn(LOGOPT_NONE, MODPREFIX
++		     "dir map %s missing or not readable", argv[0]);
++		return 1;
++	}
++
++	if (stat(ctxt->mapname, &st)) {
++		free(ctxt);
++		warn(LOGOPT_NONE, MODPREFIX
++		     "dir map %s, could not stat", argv[0]);
++		return 1;
++	}
++
++	if ( (!S_ISDIR(st.st_mode)) && (!S_ISLNK(st.st_mode)) ) {
++		free(ctxt);
++		warn(LOGOPT_NONE, MODPREFIX
++		     "dir map %s, is not a directory", argv[0]);
++	}
++
++	*context = ctxt;
++	return 0;
++}
++
++static int acceptable_dirent_p(const struct dirent *e)
++{
++  size_t namesz;
++
++
++  if (!(e->d_type == DT_REG || e->d_type == DT_LNK))
++	  return 0;
++
++  namesz = strlen(e->d_name);
++  if (!namesz)
++	  return 0;
++
++  if (e->d_name[0] == '.')
++	  return 0;
++
++  if (namesz < AUTOFS_DIR_EXTSIZ + 1 ||
++      strcmp(e->d_name + (namesz - AUTOFS_DIR_EXTSIZ),
++	     AUTOFS_DIR_EXT))
++	  return 0;
++
++  return 1;
++}
++
++
++static int include_file(struct master *master, time_t age, struct lookup_context* ctxt, struct dirent *e)
++{
++	unsigned int logopt = master->logopt;
++	char included_path[PATH_MAX + 1];
++	int included_path_len;
++	char *save_name;
++	int status;
++
++	included_path_len = snprintf(included_path,
++				     PATH_MAX + 1,
++				     "%s/%s",
++				     ctxt->mapname,
++				     e->d_name);
++	if (included_path_len > PATH_MAX)
++		return NSS_STATUS_NOTFOUND;
++
++	save_name = master->name;
++	master->name = included_path;
++
++	master->depth++;
++	debug(logopt, MODPREFIX "include: %s", master->name);
++	status = lookup_nss_read_master(master, age);
++	if (!status) {
++		warn(logopt,
++		     MODPREFIX
++		     "failed to read included master map %s",
++		     master->name);
++	}
++	master->depth--;
++
++	master->name = save_name;
++	return NSS_STATUS_SUCCESS;
++}
++
++
++int lookup_read_master(struct master *master, time_t age, void *context)
++{
++        int n, i;
++	struct dirent **namelist = NULL;
++	struct lookup_context *ctxt = (struct lookup_context *) context;
++	unsigned int logopt = master->logopt;
++	char buf[MAX_ERR_BUF];
++
++
++	if (master->depth > MAX_INCLUDE_DEPTH) {
++		error(logopt, MODPREFIX
++		      "maximum include depth exceeded %s", master->name);
++		return NSS_STATUS_UNAVAIL;
++	}
++
++	debug(logopt, MODPREFIX "scandir: %s", ctxt->mapname);
++	n = scandir(ctxt->mapname, &namelist, acceptable_dirent_p, versionsort);
++	if (n < 0) {
++	       char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
++
++		error(logopt,
++		      MODPREFIX "could not scan master map dir %s: %s",
++		      ctxt->mapname,
++		      estr);
++		return NSS_STATUS_UNAVAIL;
++	}
++
++	for (i = 0; i < n; i++) {
++		struct dirent *e = namelist[i];
++
++		include_file(master, age, ctxt, e);
++		free(e);
++	}
++	free(namelist);
++
++	return NSS_STATUS_SUCCESS;
++}
++
++int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
++{
++	ap->entry->current = NULL;
++	master_source_current_signal(ap->entry);
++	return NSS_STATUS_UNKNOWN;
++}
++
++int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *context)
++{
++	ap->entry->current = NULL;
++	master_source_current_signal(ap->entry);
++	return NSS_STATUS_UNKNOWN;
++}
++
++int lookup_done(void *context)
++{
++	struct lookup_context *ctxt = (struct lookup_context *) context;
++
++	free(ctxt);
++	return 0;
++}
+diff --git a/samples/auto.master b/samples/auto.master
+index 9fe5609..72f086c 100644
+--- a/samples/auto.master
++++ b/samples/auto.master
+@@ -12,6 +12,10 @@
+ #
+ /net	-hosts
+ #
++# Include /etc/auto.master.d/*.autofs
++#
+++dir:/etc/auto.master.d
++#
+ # Include central master map if it can be found using
+ # nsswitch sources.
+ #
Index: backfire/feeds/packages/utils/autofs/patches/110-autofs-5.0.6-fix-wait-for-master-source-mutex.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/110-autofs-5.0.6-fix-wait-for-master-source-mutex.patch
@@ -0,0 +1,84 @@
+autofs-5.0.6 - fix wait for master source mutex
+
+From: Ian Kent <ikent@redhat.com>
+
+A previous change that was meant to handle the case where the master map
+source mutex read lock count was exceeded was incorrectly done for the
+write lock case instead of the read lock case.
+---
+
+ CHANGELOG    |    1 +
+ lib/master.c |   30 +++++++++++++++---------------
+ 2 files changed, 16 insertions(+), 15 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index 1e6edd1..2352df1 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -10,6 +10,7 @@
+ - code analysis fixes part 1.
+ - fix not bind mounting local filesystem.
+ - add "dir" map-type.
++- fix wait for master source mutex.
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/lib/master.c b/lib/master.c
+index 6c89e1d..87d1269 100644
+--- a/lib/master.c
++++ b/lib/master.c
+@@ -540,38 +540,38 @@ void send_map_update_request(struct autofs_point *ap)
+ 
+ void master_source_writelock(struct master_mapent *entry)
+ {
+-	int retries = 5; /* 1 second maximum */
+ 	int status;
+ 
+-	while (retries--) {
+-		status = pthread_rwlock_wrlock(&entry->source_lock);
+-		if (status != EAGAIN)
+-			break;
+-		else {
+-                	struct timespec t = { 0, 200000000 };
+-	                struct timespec r;
+-                	while (nanosleep(&t, &r) == -1 && errno == EINTR)
+-                        	memcpy(&t, &r, sizeof(struct timespec));
+-		}
+-	}
+-
++	status = pthread_rwlock_wrlock(&entry->source_lock);
+ 	if (status) {
+ 		logmsg("master_mapent source write lock failed");
+ 		fatal(status);
+ 	}
+-
+ 	return;
+ }
+ 
+ void master_source_readlock(struct master_mapent *entry)
+ {
++	int retries = 5; /* 1 second maximum */
+ 	int status;
+ 
+-	status = pthread_rwlock_rdlock(&entry->source_lock);
++	while (retries--) {
++		status = pthread_rwlock_tryrdlock(&entry->source_lock);
++		if (status != EAGAIN && status != EBUSY)
++			break;
++		else {
++                	struct timespec t = { 0, 200000000 };
++	                struct timespec r;
++                	while (nanosleep(&t, &r) == -1 && errno == EINTR)
++                        	memcpy(&t, &r, sizeof(struct timespec));
++		}
++	}
++
+ 	if (status) {
+ 		logmsg("master_mapent source read lock failed");
+ 		fatal(status);
+ 	}
++
+ 	return;
+ }
+ 
Index: backfire/feeds/packages/utils/autofs/patches/111-autofs-5.0.6-fix-submount-shutdown-race.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/111-autofs-5.0.6-fix-submount-shutdown-race.patch
@@ -0,0 +1,141 @@
+autofs-5.0.6 - fix submount shutdown race
+
+From: Ian Kent <ikent@redhat.com>
+
+Shutdown of submounts is problematic because the kernel doesn't
+know when they are going away and so cannot block path walks
+while they shut down. After aquiring the locks that cause mount
+requests to wait, the daemon checks if the submount is active before
+finally umounting it. If the mount is found to be busy the shutdown
+is abandoned and the submount returned to a ready state.
+
+But, if a mount request arrives at the same time as the daemon is
+attempting to aquire these locks pthreads appears to become confused
+and blocks. So change to using the try version of the lock call and
+handling the return appropriately.
+---
+
+ CHANGELOG          |    1 +
+ daemon/automount.c |   76 ++++++++++++++++++++++++++++++++++++++++------------
+ 2 files changed, 60 insertions(+), 17 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index 2352df1..6035791 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -11,6 +11,7 @@
+ - fix not bind mounting local filesystem.
+ - add "dir" map-type.
+ - fix wait for master source mutex.
++- fix submount shutdown race.
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/daemon/automount.c b/daemon/automount.c
+index 376e965..4f3151f 100644
+--- a/daemon/automount.c
++++ b/daemon/automount.c
+@@ -1495,6 +1495,41 @@ static void handle_mounts_cleanup(void *arg)
+ 	return;
+ }
+ 
++static int submount_source_writelock_nested(struct autofs_point *ap)
++{
++	struct autofs_point *parent = ap->parent;
++	int status;
++
++	status = pthread_rwlock_trywrlock(&parent->entry->source_lock);
++	if (status)
++		goto done;
++
++	mounts_mutex_lock(parent);
++
++	status = pthread_rwlock_trywrlock(&ap->entry->source_lock);
++	if (status) {
++		mounts_mutex_unlock(parent);
++		master_source_unlock(parent->entry);
++	}
++
++done:
++	if (status && status != EBUSY) {
++		logmsg("submount nested master_mapent source write lock failed");
++		fatal(status);
++	}
++
++	return status;
++}
++
++static void submount_source_unlock_nested(struct autofs_point *ap)
++{
++	struct autofs_point *parent = ap->parent;
++
++	master_source_unlock(ap->entry);
++	mounts_mutex_unlock(parent);
++	master_source_unlock(parent->entry);
++}
++
+ void *handle_mounts(void *arg)
+ {
+ 	struct startup_cond *suc;
+@@ -1565,23 +1600,32 @@ void *handle_mounts(void *arg)
+ 			master_mutex_lock();
+ 
+ 			if (ap->submount) {
+-				master_source_writelock(ap->parent->entry);
+-				mounts_mutex_lock(ap->parent);
+-			}
+-
+-			master_source_writelock(ap->entry);
++				/*
++				 * If a mount request arrives before the locks are
++				 * aquired just return to ready state.
++				 */
++				ret = submount_source_writelock_nested(ap);
++				if (ret) {
++					warn(ap->logopt,
++					     "can't shutdown submount: mount in progress");
++					/* Return to ST_READY is done immediately */
++					st_add_task(ap, ST_READY);
++					master_mutex_unlock();
++					pthread_setcancelstate(cur_state, NULL);
++					continue;
++				}
++			} else
++				master_source_writelock(ap->entry);
+ 
+ 			if (ap->state != ST_SHUTDOWN) {
+ 				if (!ap->submount)
+ 					alarm_add(ap, ap->exp_runfreq);
+ 				/* Return to ST_READY is done immediately */
+ 				st_add_task(ap, ST_READY);
+-				master_source_unlock(ap->entry);
+-				if (ap->submount) {
+-					mounts_mutex_unlock(ap->parent);
+-					master_source_unlock(ap->parent->entry);
+-				}
+-
++				if (ap->submount)
++					submount_source_unlock_nested(ap);
++				else
++					master_source_unlock(ap->entry);
+ 				master_mutex_unlock();
+ 
+ 				pthread_setcancelstate(cur_state, NULL);
+@@ -1621,12 +1665,10 @@ void *handle_mounts(void *arg)
+ 				alarm_add(ap, ap->exp_runfreq);
+ 			/* Return to ST_READY is done immediately */
+ 			st_add_task(ap, ST_READY);
+-			master_source_unlock(ap->entry);
+-			if (ap->submount) {
+-				mounts_mutex_unlock(ap->parent);
+-				master_source_unlock(ap->parent->entry);
+-			}
+-
++			if (ap->submount)
++				submount_source_unlock_nested(ap);
++			else
++				master_source_unlock(ap->entry);
+ 			master_mutex_unlock();
+ 
+ 			pthread_setcancelstate(cur_state, NULL);
Index: backfire/feeds/packages/utils/autofs/patches/112-autofs-5.0.6-fix-fix-map-source-check-in-file-lookup.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/112-autofs-5.0.6-fix-fix-map-source-check-in-file-lookup.patch
@@ -0,0 +1,40 @@
+autofs-5.0.6 - fix fix map source check in file lookup
+
+From: Ian Kent <raven@themaw.net>
+
+A recent change to correct a problem with included map entry removal
+has broken a different case of included map key lookup. The check in
+previous patch was too broad and caused map key lookup for keys in an
+included multi-mount map entrys to not be found.
+---
+
+ CHANGELOG             |    1 +
+ modules/lookup_file.c |    2 +-
+ 2 files changed, 2 insertions(+), 1 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index 6035791..4064b5f 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -12,6 +12,7 @@
+ - add "dir" map-type.
+ - fix wait for master source mutex.
+ - fix submount shutdown race.
++- fix fix map source check in file lookup.
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/modules/lookup_file.c b/modules/lookup_file.c
+index 8ead07c..63b5ae7 100644
+--- a/modules/lookup_file.c
++++ b/modules/lookup_file.c
+@@ -1046,7 +1046,7 @@ do_cache_lookup:
+ 	 * instance (same map entry cache), not in a distinct source.
+ 	 */
+ 	if (me && (!me->mapent || 
+-	   (ap->type == LKP_INDIRECT && me->source != source))) {
++	   (me->source != source && *me->key != '/'))) {
+ 		while ((me = cache_lookup_key_next(me)))
+ 			if (me->source == source)
+ 				break;
Index: backfire/feeds/packages/utils/autofs/patches/113-autofs-5.0.6-add-disable-move-mount-configure-option.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/113-autofs-5.0.6-add-disable-move-mount-configure-option.patch
@@ -0,0 +1,334 @@
+autofs-5.0.6 - add disable move mount configure option
+
+From: Ian Kent <ikent@redhat.com>
+
+With the introduction of systemd the root filesystem is now usually
+marked as shared instead of private as part of the systemd sandbox
+functionality. As a consequence moving a mount from one mount point
+to another is not allowed.
+
+To resolve this a configure option (--disable-move-mount) to disable
+autofs preparing mount tree and then moving it into place has been
+added. The move mount use in autofs was needed for a small set of
+automount types with older kernels (prior to 2.6.39). So to disable
+the use of move mount it's necessary to use a recent kernel.
+---
+
+ CHANGELOG           |    1 +
+ autofs.spec         |    2 +-
+ configure           |   18 ++++++++++++++++++
+ configure.in        |   10 ++++++++++
+ daemon/automount.c  |   11 +++++++++++
+ include/config.h.in |    3 +++
+ modules/mount_nfs.c |    5 -----
+ modules/parse_sun.c |   40 +++++++++++++++++++++++++++++++++++-----
+ 8 files changed, 79 insertions(+), 11 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index 4064b5f..a1f2453 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -13,6 +13,7 @@
+ - fix wait for master source mutex.
+ - fix submount shutdown race.
+ - fix fix map source check in file lookup.
++- add disable move mount configure option.
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/autofs.spec b/autofs.spec
+index 82edd1e..510ef76 100644
+--- a/autofs.spec
++++ b/autofs.spec
+@@ -57,7 +57,7 @@ inkludera n
+ echo %{version}-%{release} > .version
+ 
+ %build
+-CFLAGS="$RPM_OPT_FLAGS -Wall" ./configure --libdir=%{_libdir} --disable-mount-locking --enable-ignore-busy --with-libtirpc
++CFLAGS="$RPM_OPT_FLAGS -Wall" ./configure --libdir=%{_libdir} --disable-mount-locking --enable-ignore-busy --with-libtirpc --disable-mount-move
+ CFLAGS="$RPM_OPT_FLAGS -Wall" make initdir=/etc/rc.d/init.d DONTSTRIP=1
+ 
+ %install
+diff --git a/configure b/configure
+index b5a3608..76b6d86 100755
+--- a/configure
++++ b/configure
+@@ -704,6 +704,7 @@ with_openldap
+ with_sasl
+ enable_ext_env
+ enable_mount_locking
++enable_mount_move
+ enable_forced_shutdown
+ enable_ignore_busy
+ '
+@@ -1326,6 +1327,7 @@ Optional Features:
+   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+   --disable-ext-env	  disable search in environment for substitution variable
+   --disable-mount-locking disable use of locking when spawning mount command
++  --disable-mount-move    disable use of mount move when when preparing tree of mounts
+   --enable-force-shutdown enable USR1 signal to force unlink umount of any
+ 			  busy mounts during shutdown
+   --enable-ignore-busy	  enable exit without umounting busy mounts during
+@@ -5349,6 +5351,22 @@ $as_echo "#define ENABLE_MOUNT_LOCKING 1" >>confdefs.h
+ fi
+ 
+ #
++# Disable use of mount move
++#
++# Check whether --enable-mount-move was given.
++if test "${enable_mount_move+set}" = set; then :
++  enableval=$enable_mount_move;
++else
++  enableval=yes
++fi
++
++if test x$enable_mount_move = xyes -o x$enableval = xyes; then
++
++$as_echo "#define ENABLE_MOUNT_MOVE 1" >>confdefs.h
++
++fi
++
++#
+ # Enable forced shutdown on USR1 signal (unlink umounts all mounts).
+ #
+ # Check whether --enable-forced-shutdown was given.
+diff --git a/configure.in b/configure.in
+index 46de65a..d3e4e54 100644
+--- a/configure.in
++++ b/configure.in
+@@ -324,6 +324,16 @@ if test x$enable_mount_locking = xyes -o x$enableval = xyes; then
+ fi
+ 
+ #
++# Disable use of mount move
++#
++AC_ARG_ENABLE(mount-move,
++[  --disable-mount-move    disable use of mount move when when preparing tree of mounts],,
++	enableval=yes)
++if test x$enable_mount_move = xyes -o x$enableval = xyes; then
++	AC_DEFINE(ENABLE_MOUNT_MOVE, 1, [Disable use of mount move when preparing tree of mounts])
++fi
++
++#
+ # Enable forced shutdown on USR1 signal (unlink umounts all mounts).
+ #
+ AC_ARG_ENABLE(forced-shutdown,
+diff --git a/daemon/automount.c b/daemon/automount.c
+index 4f3151f..6bb5aa8 100644
+--- a/daemon/automount.c
++++ b/daemon/automount.c
+@@ -1743,9 +1743,20 @@ static void show_build_info(void)
+ 	count = 22;
+ #endif
+ 
++#ifndef ENABLE_MOUNT_MOVE
++	printf("DISABLE_MOUNT_MOVE ");
++	count = count + 19;
++#endif
++
+ #ifdef ENABLE_FORCED_SHUTDOWN
+ 	printf("ENABLE_FORCED_SHUTDOWN ");
+ 	count = count + 23;
++
++	if (count > 60) {
++		printf("\n  ");
++		count = 0;
++	}
++
+ #endif
+ 
+ #ifdef ENABLE_IGNORE_BUSY_MOUNTS
+diff --git a/include/config.h.in b/include/config.h.in
+index 4a3a990..97a8d2d 100644
+--- a/include/config.h.in
++++ b/include/config.h.in
+@@ -12,6 +12,9 @@
+ /* Disable use of locking when spawning mount command */
+ #undef ENABLE_MOUNT_LOCKING
+ 
++/* Disable use of mount move when preparing tree of mounts */
++#undef ENABLE_MOUNT_MOVE
++
+ /* define if you have E2FSCK */
+ #undef HAVE_E2FSCK
+ 
+diff --git a/modules/mount_nfs.c b/modules/mount_nfs.c
+index 8b567d2..7eab728 100644
+--- a/modules/mount_nfs.c
++++ b/modules/mount_nfs.c
+@@ -163,11 +163,6 @@ int mount_mount(struct autofs_point *ap, const char *root, const char *name, int
+ 	if (root[len - 1] == '/') {
+ 		len = snprintf(fullpath, len, "%s", root);
+ 	} else if (*name == '/') {
+-		/*
+-		 * Direct or offset mount, name is absolute path so
+-		 * don't use root (but with move mount changes root
+-		 * is now the same as name).
+-		 */
+ 		len = sprintf(fullpath, "%s", root);
+ 	} else {
+ 		len = sprintf(fullpath, "%s/%s", root, name);
+diff --git a/modules/parse_sun.c b/modules/parse_sun.c
+index 021850d..13b8af8 100644
+--- a/modules/parse_sun.c
++++ b/modules/parse_sun.c
+@@ -1028,6 +1028,7 @@ static int parse_mapent(const char *ent, char *g_options, char **options, char *
+ 	return (p - ent);
+ }
+ 
++#ifdef ENABLE_MOUNT_MOVE
+ static int move_mount(struct autofs_point *ap,
+ 		      const char *mm_tmp_root, const char *mm_root,
+ 		      unsigned int move)
+@@ -1063,6 +1064,7 @@ static int move_mount(struct autofs_point *ap,
+ 
+ 	return 1;
+ }
++#endif
+ 
+ static void cleanup_multi_root(struct autofs_point *ap, const char *root,
+ 					 const char *path, unsigned int move)
+@@ -1145,6 +1147,7 @@ static void cleanup_multi_triggers(struct autofs_point *ap,
+ 	return;
+ }
+ 
++#ifdef ENABLE_MOUNT_MOVE
+ static int check_fstype_autofs_option(const char *options)
+ {
+ 	char *tok, *tokbuf;
+@@ -1171,24 +1174,27 @@ static int check_fstype_autofs_option(const char *options)
+ 
+ 	return found;
+ }
++#endif
+ 
+ static int mount_subtree(struct autofs_point *ap, struct mapent *me,
+ 			 const char *name, char *loc, char *options, void *ctxt)
+ {
+ 	struct mapent *mm;
+ 	struct mapent *ro;
+-	char t_dir[] = "/tmp/autoXXXXXX";
+-	char *mnt_tmp_root, *mm_root, *mm_base, *mm_key;
++	char *mm_root, *mm_base, *mm_key;
+ 	const char *mnt_root, *target;
+ 	unsigned int mm_root_len, mnt_root_len;
+ 	int start, ret = 0, rv;
+-	unsigned int move;
++	unsigned int move = MOUNT_MOVE_NONE;
++#ifdef ENABLE_MOUNT_MOVE
++	char t_dir[] = "/tmp/autoXXXXXX";
++	char *mnt_tmp_root = NULL;
++#endif
+ 
+ 	rv = 0;
+ 
+ 	mm = me->multi;
+ 	mm_key = mm->key;
+-	move = MOUNT_MOVE_NONE;
+ 
+ 	if (*mm_key == '/') {
+ 		mm_root = mm_key;
+@@ -1202,7 +1208,10 @@ static int mount_subtree(struct autofs_point *ap, struct mapent *me,
+ 	}
+ 	mm_root_len = strlen(mm_root);
+ 
+-	mnt_tmp_root = NULL;
++#ifndef ENABLE_MOUNT_MOVE
++	mnt_root = mm_root;
++	mnt_root_len = mm_root_len;
++#else
+ 	if (ap->flags & MOUNT_FLAG_REMOUNT) {
+ 		mnt_root = mm_root;
+ 		mnt_root_len = mm_root_len;
+@@ -1213,6 +1222,7 @@ static int mount_subtree(struct autofs_point *ap, struct mapent *me,
+ 		mnt_root_len = strlen(mnt_root);
+ 		mnt_tmp_root = (char *) mnt_root;
+ 	}
++#endif
+ 
+ 	if (me == me->multi) {
+ 		/* name = NULL */
+@@ -1238,11 +1248,13 @@ static int mount_subtree(struct autofs_point *ap, struct mapent *me,
+ 			}
+ 			ro_len = strlen(ro_loc);
+ 
++#ifdef ENABLE_MOUNT_MOVE
+ 			if (!(ap->flags & MOUNT_FLAG_REMOUNT)) {
+ 				move = MOUNT_MOVE_OTHER;
+ 				if (check_fstype_autofs_option(myoptions))
+ 					move = MOUNT_MOVE_AUTOFS;
+ 			}
++#endif
+ 
+ 			tmp = alloca(mnt_root_len + 1);
+ 			strcpy(tmp, mnt_root);
+@@ -1266,7 +1278,9 @@ static int mount_subtree(struct autofs_point *ap, struct mapent *me,
+ 				goto error_out;
+ 			}
+ 		} else if (rv <= 0) {
++#ifdef ENABLE_MOUNT_MOVE
+ 			move = MOUNT_MOVE_NONE;
++#endif
+ 			ret = mount_multi_triggers(ap, me, mm_root, start, mm_base);
+ 			if (ret == -1) {
+ 				error(ap->logopt, MODPREFIX
+@@ -1279,11 +1293,21 @@ static int mount_subtree(struct autofs_point *ap, struct mapent *me,
+ 		int loclen = strlen(loc);
+ 		int namelen = strlen(name);
+ 
++#ifndef ENABLE_MOUNT_MOVE
++		/*
++		 * When using move mount to mount offsets or direct mounts
++		 * the base of the tree can be the base of the temporary
++		 * mount point it needs to be the full path when not moving
++		 * the mount after construction.
++		 */
++		mnt_root = name;
++#else
+ 		if (!(ap->flags & MOUNT_FLAG_REMOUNT)) {
+ 			move = MOUNT_MOVE_OTHER;
+ 			if (check_fstype_autofs_option(options))
+ 				move = MOUNT_MOVE_AUTOFS;
+ 		}
++#endif
+ 
+ 		/* name = mm_root + mm_base */
+ 		/* destination = mm_root + mm_base = name */
+@@ -1303,7 +1327,9 @@ static int mount_subtree(struct autofs_point *ap, struct mapent *me,
+ 		} else if (rv < 0) {
+ 			char *mm_root_base = alloca(strlen(mm_root) + strlen(mm_base) + 1);
+ 	
++#ifdef ENABLE_MOUNT_MOVE
+ 			move = MOUNT_MOVE_NONE;
++#endif
+ 
+ 			strcpy(mm_root_base, mm_root);
+ 			strcat(mm_root_base, mm_base);
+@@ -1318,6 +1344,7 @@ static int mount_subtree(struct autofs_point *ap, struct mapent *me,
+ 		}
+ 	}
+ 
++#ifdef ENABLE_MOUNT_MOVE
+ 	if (!move_mount(ap, mnt_root, target, move)) {
+ 		cleanup_multi_triggers(ap, me, mnt_root, start, mm_base);
+ 		cleanup_multi_root(ap, mnt_root, mm_root, move);
+@@ -1326,6 +1353,7 @@ static int mount_subtree(struct autofs_point *ap, struct mapent *me,
+ 
+ 	if (mnt_tmp_root)
+ 		rmdir(mnt_tmp_root);
++#endif
+ 
+ 	/* Mount for base of tree failed */
+ 	if (rv > 0)
+@@ -1341,8 +1369,10 @@ static int mount_subtree(struct autofs_point *ap, struct mapent *me,
+ 	return rv;
+ 
+ error_out:
++#ifdef ENABLE_MOUNT_MOVE
+ 	if (mnt_tmp_root)
+ 		rmdir(mnt_tmp_root);
++#endif
+ 
+ 	return 1;
+ }
Index: backfire/feeds/packages/utils/autofs/patches/114-autofs-5.0.6-fix-lsb-service-name-in-init-script-2.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/114-autofs-5.0.6-fix-lsb-service-name-in-init-script-2.patch
@@ -0,0 +1,45 @@
+autofs-5.0.6 - fix lsb service name in init script 2
+
+From: Ian Kent <raven@themaw.net>
+
+The "Required-Start:" and "Required-Stop:" in the init script header
+incorrectly uses $ypbind instead of ypbind. This isn't correct as
+using names starting with a $ is reserved for standards-defined
+facilities.
+---
+
+ redhat/autofs.init.in |    4 ++--
+ samples/rc.autofs.in  |    4 ++--
+ 2 files changed, 4 insertions(+), 4 deletions(-)
+
+
+diff --git a/redhat/autofs.init.in b/redhat/autofs.init.in
+index 86b7eb4..48d387d 100644
+--- a/redhat/autofs.init.in
++++ b/redhat/autofs.init.in
+@@ -9,8 +9,8 @@
+ #
+ ### BEGIN INIT INFO
+ # Provides: autofs
+-# Required-Start: $network $ypbind
+-# Required-Stop: $network $ypbind
++# Required-Start: $network ypbind
++# Required-Stop: $network ypbind
+ # Default-Start: 3 4 5
+ # Default-Stop: 0 1 2 6
+ # Short-Description: Automounts filesystems on demand
+diff --git a/samples/rc.autofs.in b/samples/rc.autofs.in
+index 0306ef6..35667ba 100644
+--- a/samples/rc.autofs.in
++++ b/samples/rc.autofs.in
+@@ -8,8 +8,8 @@
+ #
+ ### BEGIN INIT INFO
+ # Provides: autofs
+-# Required-Start: $network $ypbind
+-# Required-Stop: $network $ypbind
++# Required-Start: $network ypbind
++# Required-Stop: $network ypbind
+ # Default-Start: 3 4 5
+ # Default-Stop: 0 1 2 6
+ # Short-Description: Automounts filesystems on demand
Index: backfire/feeds/packages/utils/autofs/patches/115-autofs-5.0.6-fix-ipv6-name-lookup-check.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/115-autofs-5.0.6-fix-ipv6-name-lookup-check.patch
@@ -0,0 +1,67 @@
+autofs-5.0.6 - fix ipv6 name lookup check
+
+From: Ian Kent <raven@themaw.net>
+
+The host address must be used when the host name has multiple
+addresses since we need to mount the specific host and so that
+it is known what host log entries refer to.
+
+But the check for multiple addresses can be wrong because there
+is no distinction between ipv4 and ipv6 addresses. Change the
+check to use the host name when mounting if neither the ipv4
+or the ipv6 addresses have more than one record.
+---
+
+ CHANGELOG            |    1 +
+ modules/replicated.c |   17 +++++++++++++++--
+ 2 files changed, 16 insertions(+), 2 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index a1f2453..923669f 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -14,6 +14,7 @@
+ - fix submount shutdown race.
+ - fix fix map source check in file lookup.
+ - add disable move mount configure option.
++- fix ipv6 name lookup check.
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/modules/replicated.c b/modules/replicated.c
+index eee1a06..b100c9c 100644
+--- a/modules/replicated.c
++++ b/modules/replicated.c
+@@ -1117,7 +1117,7 @@ static int add_host_addrs(struct host **list, const char *host,
+ 	char *name = n_ptr = strdup(host);
+ 	int len;
+ 	char buf[MAX_ERR_BUF];
+-	int rr = 0;
++	int rr = 0, rr4 = 0, rr6 = 0;
+ 	int ret;
+ 
+ 	if (!name) {
+@@ -1167,8 +1167,21 @@ try_name:
+ 	}
+ 
+ 	this = ni;
+-	if (this->ai_next)
++	while (this->ai_next) {
++		if (this->ai_family == AF_INET) {
++			struct sockaddr_in *addr = (struct sockaddr_in *) this->ai_addr;
++			if (addr->sin_addr.s_addr != INADDR_LOOPBACK)
++				rr4++;
++		} else if (this->ai_family == AF_INET6) {
++			struct sockaddr_in6 *addr = (struct sockaddr_in6 *) this->ai_addr;
++			if (!IN6_IS_ADDR_LOOPBACK(addr->sin6_addr.__in6_u.__u6_addr32))
++				rr6++;
++		}
++		this = this->ai_next;
++	}
++	if (rr4 > 1 || rr6 > 1)
+ 		rr++;
++	this = ni;
+ 	while (this) {
+ 		ret = add_new_host(list, host, weight, this, rr, options);
+ 		if (!ret)
Index: backfire/feeds/packages/utils/autofs/patches/116-autofs-5.0.6-fix-ipv6-rpc-calls.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/116-autofs-5.0.6-fix-ipv6-rpc-calls.patch
@@ -0,0 +1,537 @@
+autofs-5.0.6 - fix ipv6 rpc calls
+
+From: Ian Kent <ikent@redhat.com>
+
+There is a mistake in the way autofs uses libtirpc. Two IPv6 compatibiliy
+functions were thought to be included when in fact they were not and would
+not actually work with IPv6 anyway.
+
+To fix that the libtirpc interface code needed to be re-written. Portmap
+(using libtirpc calls) is still used to get service port numbers, rather
+than rpcbind.
+---
+
+ CHANGELOG            |    1 
+ lib/rpc_subs.c       |  370 ++++++++++++++++++++------------------------------
+ modules/replicated.c |    8 +
+ 3 files changed, 155 insertions(+), 224 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index 923669f..0394c74 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -15,6 +15,7 @@
+ - fix fix map source check in file lookup.
+ - add disable move mount configure option.
+ - fix ipv6 name lookup check.
++- fix ipv6 rpc calls.
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/lib/rpc_subs.c b/lib/rpc_subs.c
+index af8c101..ba679a5 100644
+--- a/lib/rpc_subs.c
++++ b/lib/rpc_subs.c
+@@ -62,89 +62,6 @@ static const rpcvers_t mount_vers[] = {
+ static int connect_nb(int, struct sockaddr *, socklen_t, struct timeval *);
+ inline void dump_core(void);
+ 
+-static CLIENT *rpc_clntudp_create(struct sockaddr *addr, struct conn_info *info, int *fd)
+-{
+-	struct sockaddr_in *in4_raddr;
+-	struct sockaddr_in6 *in6_raddr;
+-	CLIENT *client = NULL;
+-
+-	switch (addr->sa_family) {
+-	case AF_INET:
+-		in4_raddr = (struct sockaddr_in *) addr;
+-		in4_raddr->sin_port = htons(info->port);
+-		client = clntudp_bufcreate(in4_raddr,
+-					   info->program, info->version,
+-					   info->timeout, fd,
+-					   info->send_sz, info->recv_sz);
+-		break;
+-
+-	case AF_INET6:
+-#ifndef INET6
+-		/* Quiet compile warning */
+-		in6_raddr = NULL;
+-#else
+-		in6_raddr = (struct sockaddr_in6 *) addr;
+-		in6_raddr->sin6_port = htons(info->port);
+-		client = clntudp6_bufcreate(in6_raddr,
+-					    info->program, info->version,
+-					    info->timeout, fd,
+-					    info->send_sz, info->recv_sz);
+-#endif
+-		break;
+-
+-	default:
+-		break;
+-	}
+-
+-	return client;
+-}
+-
+-static CLIENT *rpc_clnttcp_create(struct sockaddr *addr, struct conn_info *info, int *fd)
+-{
+-	struct sockaddr_in *in4_raddr;
+-	struct sockaddr_in6 *in6_raddr;
+-	CLIENT *client = NULL;
+-	socklen_t slen;
+-
+-	switch (addr->sa_family) {
+-	case AF_INET:
+-		in4_raddr = (struct sockaddr_in *) addr;
+-		in4_raddr->sin_port = htons(info->port);
+-		slen = sizeof(struct sockaddr_in);
+-
+-		if (connect_nb(*fd, addr, slen, &info->timeout) < 0)
+-			break;
+-
+-		client = clnttcp_create(in4_raddr,
+-					info->program, info->version, fd,
+-					info->send_sz, info->recv_sz);
+-		break;
+-
+-	case AF_INET6:
+-#ifndef INET6
+-		/* Quiet compile warning */
+-		in6_raddr = NULL;
+-#else
+-		in6_raddr = (struct sockaddr_in6 *) addr;
+-		in6_raddr->sin6_port = htons(info->port);
+-		slen = sizeof(struct sockaddr_in6);
+-
+-		if (connect_nb(*fd, addr, slen, &info->timeout) < 0)
+-			break;
+-
+-		client = clnttcp6_create(in6_raddr,
+-					 info->program, info->version, fd,
+-					 info->send_sz, info->recv_sz);
+-#endif
+-		break;
+-
+-	default:
+-		break;
+-	}
+-
+-	return client;
+-}
+-
+ /*
+  *  Perform a non-blocking connect on the socket fd.
+  *
+@@ -232,12 +149,12 @@ done:
+ 	return ret;
+ }
+ 
++#ifndef WITH_LIBTIRPC
+ static CLIENT *rpc_do_create_client(struct sockaddr *addr, struct conn_info *info, int *fd)
+ {
+ 	CLIENT *client = NULL;
+-	struct sockaddr *laddr;
+ 	struct sockaddr_in in4_laddr;
+-	struct sockaddr_in6 in6_laddr;
++	struct sockaddr_in in4_raddr;
+ 	int type, proto;
+ 	socklen_t slen;
+ 
+@@ -252,48 +169,41 @@ static CLIENT *rpc_do_create_client(struct sockaddr *addr, struct conn_info *inf
+ 	 * layer, it would bind to a reserved port, which has been shown
+ 	 * to exhaust the reserved port range in some situations.
+ 	 */
+-	switch (addr->sa_family) {
+-	case AF_INET:
+-		in4_laddr.sin_family = AF_INET;
+-		in4_laddr.sin_port = htons(0);
+-		in4_laddr.sin_addr.s_addr = htonl(INADDR_ANY);
+-		slen = sizeof(struct sockaddr_in);
+-		laddr = (struct sockaddr *) &in4_laddr;
+-		break;
+-
+-	case AF_INET6:
+-#ifndef INET6
+-		/* Quiet compiler */
+-		in6_laddr.sin6_family = AF_INET6;
+-		return NULL;
+-#else
+-		in6_laddr.sin6_family = AF_INET6;
+-		in6_laddr.sin6_port = htons(0);
+-		in6_laddr.sin6_addr = in6addr_any;
+-		slen = sizeof(struct sockaddr_in6);
+-		laddr = (struct sockaddr *) &in6_laddr;
+-		break;
+-#endif
+-	default:
+-		return NULL;
+-	}
++	in4_laddr.sin_family = AF_INET;
++	in4_laddr.sin_port = htons(0);
++	in4_laddr.sin_addr.s_addr = htonl(INADDR_ANY);
++	slen = sizeof(struct sockaddr_in);
+ 
+ 	if (!info->client) {
++		struct sockaddr *laddr;
++
+ 		*fd = open_sock(addr->sa_family, type, proto);
+ 		if (*fd < 0)
+ 			return NULL;
+ 
++		laddr = (struct sockaddr *) &in4_laddr;
+ 		if (bind(*fd, laddr, slen) < 0)
+ 			return NULL;
+ 	}
+ 
++	in4_raddr = (struct sockaddr_in *) addr;
++	in4_raddr->sin_port = htons(info->port);
++
+ 	switch (info->proto->p_proto) {
+ 	case IPPROTO_UDP:
+-		client = rpc_clntudp_create(addr, info, fd);
++		client = clntudp_bufcreate(in4_raddr,
++					   info->program, info->version,
++					   info->timeout, fd,
++					   info->send_sz, info->recv_sz);
+ 		break;
+ 
+ 	case IPPROTO_TCP:
+-		client = rpc_clnttcp_create(addr, info, fd);
++		if (connect_nb(*fd, addr, slen, &info->timeout) < 0)
++			break;
++
++		client = clnttcp_create(in4_raddr,
++					info->program, info->version, fd,
++					info->send_sz, info->recv_sz);
+ 		break;
+ 
+ 	default:
+@@ -302,20 +212,126 @@ static CLIENT *rpc_do_create_client(struct sockaddr *addr, struct conn_info *inf
+ 
+ 	return client;
+ }
++#else
++struct netconfig *find_netconf(void *handle, char *family, char *proto)
++{
++	struct netconfig *nconf;
++
++	while ((nconf = getnetconfig(handle))) {
++		if ((strcmp(nconf->nc_protofmly, family) == 0) &&
++		    (strcmp(nconf->nc_proto, proto) == 0))
++			break;
++	}
++
++	return nconf;
++}
++
++static CLIENT *rpc_do_create_client(struct sockaddr *addr, struct conn_info *info, int *fd)
++{
++	CLIENT *client = NULL;
++	struct sockaddr_in in4_laddr;
++	struct sockaddr_in6 in6_laddr;
++	struct sockaddr *laddr = NULL;
++	struct netconfig *nconf;
++	struct netbuf nb_addr;
++	int type, proto;
++	char *nc_family, *nc_proto;
++	void *handle;
++	size_t slen;
++
++	proto = info->proto->p_proto;
++	if (proto == IPPROTO_UDP) {
++		type = SOCK_DGRAM;
++		nc_proto = NC_UDP;
++	} else {
++		type = SOCK_STREAM;
++		nc_proto = NC_TCP;
++	}
++
++	/*
++	 * bind to any unused port.  If we left this up to the rpc
++	 * layer, it would bind to a reserved port, which has been shown
++	 * to exhaust the reserved port range in some situations.
++	 */
++	if (addr->sa_family == AF_INET) {
++		struct sockaddr_in *in4_raddr = (struct sockaddr_in *) addr;
++		in4_laddr.sin_family = AF_INET;
++		in4_laddr.sin_port = htons(0);
++		in4_laddr.sin_addr.s_addr = htonl(INADDR_ANY);
++		laddr = (struct sockaddr *) &in4_laddr;
++		in4_raddr->sin_port = htons(info->port);
++		slen = sizeof(struct sockaddr_in);
++		nc_family = NC_INET;
++	} else if (addr->sa_family == AF_INET6) {
++		struct sockaddr_in6 *in6_raddr = (struct sockaddr_in6 *) addr;
++		in6_laddr.sin6_family = AF_INET6;
++		in6_laddr.sin6_port = htons(0);
++		in6_laddr.sin6_addr = in6addr_any;
++		laddr = (struct sockaddr *) &in6_laddr;
++		in6_raddr->sin6_port = htons(info->port);
++		slen = sizeof(struct sockaddr_in6);
++		nc_family = NC_INET6;
++	} else
++		return NULL;
++
++	handle = setnetconfig();
++	if (!handle)
++		return NULL;
++
++	nconf = find_netconf(handle, nc_family, nc_proto);
++	if (!nconf) {
++		endnetconfig(handle);
++		return NULL;
++	}
++
++	/*
++	 * bind to any unused port.  If we left this up to the rpc layer,
++	 * it would bind to a reserved port, which has been shown to
++	 * exhaust the reserved port range in some situations.
++	 */
++	if (!info->client) {
++		*fd = open_sock(addr->sa_family, type, proto);
++		if (*fd < 0) {
++			endnetconfig(handle);
++			return NULL;
++		}
++
++		if (bind(*fd, laddr, slen) < 0) {
++			endnetconfig(handle);
++			return NULL;
++		}
++	}
++
++	nb_addr.maxlen = nb_addr.len = slen;
++	nb_addr.buf = addr;
++
++	if (info->proto->p_proto == IPPROTO_TCP) {
++		if (connect_nb(*fd, addr, slen, &info->timeout) < 0) {
++			endnetconfig(handle);
++			return NULL;
++		}
++	}
++
++	client = clnt_tli_create(*fd, nconf, &nb_addr,
++				 info->program, info->version,
++				 info->send_sz, info->recv_sz);
++
++	endnetconfig(handle);
++
++	return client;
++}
++#endif
+ 
+ /*
+- * Create a UDP RPC client
++ * Create an RPC client
+  */
+-static CLIENT *create_udp_client(struct conn_info *info)
++static CLIENT *create_client(struct conn_info *info)
+ {
+ 	CLIENT *client = NULL;
+ 	struct addrinfo *ai, *haddr;
+ 	struct addrinfo hints;
+ 	int fd, ret;
+ 
+-	if (info->proto->p_proto != IPPROTO_UDP)
+-		return NULL;
+-
+ 	fd = RPC_ANYSOCK;
+ 
+ 	if (info->client) {
+@@ -355,6 +371,11 @@ static CLIENT *create_udp_client(struct conn_info *info)
+ 
+ 	haddr = ai;
+ 	while (haddr) {
++		if (haddr->ai_protocol != info->proto->p_proto) {
++			haddr = haddr->ai_next;
++			continue;
++		}
++
+ 		client = rpc_do_create_client(haddr->ai_addr, info, &fd);
+ 		if (client)
+ 			break;
+@@ -408,7 +429,7 @@ int rpc_udp_getclient(struct conn_info *info,
+ 	info->program = program;
+ 	info->version = version;
+ 
+-	client = create_udp_client(info);
++	client = create_client(info);
+ 
+ 	if (!client)
+ 		return 0;
+@@ -428,92 +449,6 @@ void rpc_destroy_udp_client(struct conn_info *info)
+ 	return;
+ }
+ 
+-/*
+- * Create a TCP RPC client using non-blocking connect
+- */
+-static CLIENT *create_tcp_client(struct conn_info *info)
+-{
+-	CLIENT *client = NULL;
+-	struct addrinfo *ai, *haddr;
+-	struct addrinfo hints;
+-	int fd, ret;
+-
+-	if (info->proto->p_proto != IPPROTO_TCP)
+-		return NULL;
+-
+-	fd = RPC_ANYSOCK;
+-
+-	if (info->client) {
+-		if (!clnt_control(info->client, CLGET_FD, (char *) &fd)) {
+-			fd = RPC_ANYSOCK;
+-			clnt_destroy(info->client);
+-			info->client = NULL;
+-		} else {
+-			clnt_control(info->client, CLSET_FD_NCLOSE, NULL);
+-			clnt_destroy(info->client);
+-		}
+-	}
+-
+-	if (info->addr) {
+-		client = rpc_do_create_client(info->addr, info, &fd);
+-		if (client)
+-			goto done;
+-
+-		if (!info->client) {
+-			close(fd);
+-			fd = RPC_ANYSOCK;
+-		}
+-	}
+-
+-	memset(&hints, 0, sizeof(hints));
+-	hints.ai_flags = AI_ADDRCONFIG;
+-	hints.ai_family = AF_UNSPEC;
+-	hints.ai_socktype = SOCK_STREAM;
+-
+-	ret = getaddrinfo(info->host, NULL, &hints, &ai);
+-	if (ret) {
+-		error(LOGOPT_ANY,
+-		      "hostname lookup failed: %s", gai_strerror(ret));
+-		info->client = NULL;
+-		goto out_close;
+-	}
+-
+-	haddr = ai;
+-	while (haddr) {
+-		client = rpc_do_create_client(haddr->ai_addr, info, &fd);
+-		if (client)
+-			break;
+-
+-		if (!info->client && fd != RPC_ANYSOCK) {
+-			close(fd);
+-			fd = RPC_ANYSOCK;
+-		}
+-
+-		haddr = haddr->ai_next;
+-	}
+-
+-	freeaddrinfo(ai);
+-
+-	if (!client) {
+-		info->client = NULL;
+-		goto out_close;
+-	}
+-done:
+-	/* Close socket fd on destroy, as is default for rpcowned fds */
+-	if  (!clnt_control(client, CLSET_FD_CLOSE, NULL)) {
+-		clnt_destroy(client);
+-		info->client = NULL;
+-		goto out_close;
+-	}
+-
+-	return client;
+-
+-out_close:
+-	if (fd != -1)
+-		close(fd);
+-	return NULL;
+-}
+-
+ int rpc_tcp_getclient(struct conn_info *info,
+ 		      unsigned int program, unsigned int version)
+ {
+@@ -533,7 +468,7 @@ int rpc_tcp_getclient(struct conn_info *info,
+ 	info->program = program;
+ 	info->version = version;
+ 
+-	client = create_tcp_client(info);
++	client = create_client(info);
+ 
+ 	if (!client)
+ 		return 0;
+@@ -593,12 +528,9 @@ int rpc_portmap_getclient(struct conn_info *info,
+ 	info->close_option = option;
+ 	info->client = NULL;
+ 
+-	if (pe_proto->p_proto == IPPROTO_TCP) {
++	if (pe_proto->p_proto == IPPROTO_TCP)
+ 		info->timeout.tv_sec = PMAP_TOUT_TCP;
+-		client = create_tcp_client(info);
+-	} else
+-		client = create_udp_client(info);
+-
++	client = create_client(info);
+ 	if (!client)
+ 		return 0;
+ 
+@@ -635,11 +567,7 @@ unsigned short rpc_portmap_getport(struct conn_info *info, struct pmap *parms)
+ 		pmap_info.send_sz = RPCSMALLMSGSIZE;
+ 		pmap_info.recv_sz = RPCSMALLMSGSIZE;
+ 
+-		if (proto == IPPROTO_TCP)
+-			client = create_tcp_client(&pmap_info);
+-		else
+-			client = create_udp_client(&pmap_info);
+-
++		client = create_client(&pmap_info);
+ 		if (!client)
+ 			return 0;
+ 	}
+@@ -700,10 +628,8 @@ int rpc_ping_proto(struct conn_info *info)
+ 		if (info->proto->p_proto == IPPROTO_UDP) {
+ 			info->send_sz = UDPMSGSIZE;
+ 			info->recv_sz = UDPMSGSIZE;
+-			client = create_udp_client(info);
+-		} else
+-			client = create_tcp_client(info);
+-
++		}
++		client = create_client(info);
+ 		if (!client)
+ 			return 0;
+ 	}
+@@ -857,10 +783,8 @@ static int rpc_get_exports_proto(struct conn_info *info, exports *exp)
+ 	if (info->proto->p_proto == IPPROTO_UDP) {
+ 		info->send_sz = UDPMSGSIZE;
+ 		info->recv_sz = UDPMSGSIZE;
+-		client = create_udp_client(info);
+-	} else
+-		client = create_tcp_client(info);
+-
++	}
++	client = create_client(info);
+ 	if (!client)
+ 		return 0;
+ 
+diff --git a/modules/replicated.c b/modules/replicated.c
+index b100c9c..b4f6da2 100644
+--- a/modules/replicated.c
++++ b/modules/replicated.c
+@@ -1095,7 +1095,13 @@ static int add_new_host(struct host **list,
+ 	if (prx == PROXIMITY_ERROR)
+ 		return 0;
+ 
+-	addr_len = sizeof(struct sockaddr);
++	if (host_addr->ai_addr->sa_family == AF_INET)
++		addr_len = INET_ADDRSTRLEN;
++	else if (host_addr->ai_addr->sa_family == AF_INET6)
++		addr_len = INET6_ADDRSTRLEN;
++	else
++		return 0;
++
+ 	new = new_host(host, host_addr->ai_addr, addr_len, prx, weight, options);
+ 	if (!new)
+ 		return 0;
Index: backfire/feeds/packages/utils/autofs/patches/117-autofs-5.0.6-fix-ipv6-configure-check.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/117-autofs-5.0.6-fix-ipv6-configure-check.patch
@@ -0,0 +1,195 @@
+autofs-5.0.6 - fix ipv6 configure check
+
+From: Ian Kent <ikent@redhat.com>
+
+Since the functions clntudp6_bufcreate() and clnttcp6_create() of
+libtirpc were never actually included in the library our reference
+to clntudp6_bufcreate() in configure needs to be removed.
+
+Having redone the libtirpc interface (after realizing these functions
+were defined but not actually included in the library) checking for
+IPv6 support can't be done now and we need to rely on the transport
+independent nature of libtirpc to take care of this. So the INET6
+checks have been replaced with WITH_LIBTIRPC checks instead.
+---
+
+ CHANGELOG            |    1 +
+ aclocal.m4           |   36 ------------------------------------
+ configure            |   46 ----------------------------------------------
+ include/config.h.in  |    3 ---
+ modules/replicated.c |   10 +++++++---
+ 5 files changed, 8 insertions(+), 88 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index 0394c74..076830f 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -16,6 +16,7 @@
+ - add disable move mount configure option.
+ - fix ipv6 name lookup check.
+ - fix ipv6 rpc calls.
++- fix ipv6 configure check.
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/aclocal.m4 b/aclocal.m4
+index 9f1e144..e1e12f7 100644
+--- a/aclocal.m4
++++ b/aclocal.m4
+@@ -324,41 +324,6 @@ LIBS="$af_check_ldap_parse_page_control_save_libs"
+ ])
+ 
+ dnl --------------------------------------------------------------------------
+-dnl AF_CHECK_LIBTIRPC_IPV6
+-dnl
+-dnl Use libtirpc for rpc transport
+-dnl --------------------------------------------------------------------------
+-AC_DEFUN([AF_CHECK_LIBTIRPC_IPV6],
+-[AC_MSG_CHECKING(if libtirpc has IPv6 support)
+-
+-# save current flags
+-af_check_libtirpc_ipv6_save_cflags="$CFLAGS"
+-af_check_libtirpc_ipv6_save_ldflags="$LDFLAGS"
+-CFLAGS="$CFLAGS -I/usr/include/tirpc"
+-LDFLAGS="$LDFLAGS -ltirpc"
+-
+-AC_TRY_LINK(
+-    [ #define INET6
+-      #include <rpc/rpc.h> ],
+-    [ CLIENT *cl;
+-      struct sockaddr_in6 addr;
+-      int fd;
+-      unsigned long ul; struct timeval t; unsigned int ui;
+-      cl = clntudp6_bufcreate(&addr,ul,ul,t,&fd,ui,ui); ],
+-    [ af_have_libtirpc_ipv6=yes
+-      AC_MSG_RESULT(yes) ],
+-    [ AC_MSG_RESULT(no) ])
+-
+-if test "$af_have_libtirpc_ipv6" = "yes"; then
+-    AC_DEFINE(INET6,1, [Use IPv6 with libtirpc])
+-fi
+-
+-# restore flags
+-CFLAGS="$af_check_libtirpc_ipv6_save_cflags"
+-LDFLAGS="$af_check_libtirpc_ipv6_save_ldflags"
+-])
+-
+-dnl --------------------------------------------------------------------------
+ dnl AF_CHECK_LIBTIRPC
+ dnl
+ dnl Use libtirpc for rpc transport
+@@ -399,7 +364,6 @@ AC_ARG_WITH(libtirpc,
+ [  --with-libtirpc         use libtirpc if available],
+ [if test "$withval" = yes; then
+   AF_CHECK_LIBTIRPC()
+-  AF_CHECK_LIBTIRPC_IPV6()
+ else
+   AC_MSG_RESULT(no)
+ fi], [AC_MSG_RESULT(no)])
+diff --git a/configure b/configure
+index 76b6d86..62599a9 100755
+--- a/configure
++++ b/configure
+@@ -3087,52 +3087,6 @@ fi
+ CFLAGS="$af_check_libtirpc_save_cflags"
+ LDFLAGS="$af_check_libtirpc_save_ldflags"
+ 
+-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if libtirpc has IPv6 support" >&5
+-$as_echo_n "checking if libtirpc has IPv6 support... " >&6; }
+-
+-# save current flags
+-af_check_libtirpc_ipv6_save_cflags="$CFLAGS"
+-af_check_libtirpc_ipv6_save_ldflags="$LDFLAGS"
+-CFLAGS="$CFLAGS -I/usr/include/tirpc"
+-LDFLAGS="$LDFLAGS -ltirpc"
+-
+-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+-/* end confdefs.h.  */
+- #define INET6
+-      #include <rpc/rpc.h>
+-int
+-main ()
+-{
+- CLIENT *cl;
+-      struct sockaddr_in6 addr;
+-      int fd;
+-      unsigned long ul; struct timeval t; unsigned int ui;
+-      cl = clntudp6_bufcreate(&addr,ul,ul,t,&fd,ui,ui);
+-  ;
+-  return 0;
+-}
+-_ACEOF
+-if ac_fn_c_try_link "$LINENO"; then :
+-   af_have_libtirpc_ipv6=yes
+-      { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+-$as_echo "yes" >&6; }
+-else
+-   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+-$as_echo "no" >&6; }
+-fi
+-rm -f core conftest.err conftest.$ac_objext \
+-    conftest$ac_exeext conftest.$ac_ext
+-
+-if test "$af_have_libtirpc_ipv6" = "yes"; then
+-
+-$as_echo "#define INET6 1" >>confdefs.h
+-
+-fi
+-
+-# restore flags
+-CFLAGS="$af_check_libtirpc_ipv6_save_cflags"
+-LDFLAGS="$af_check_libtirpc_ipv6_save_ldflags"
+-
+ else
+   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+ $as_echo "no" >&6; }
+diff --git a/include/config.h.in b/include/config.h.in
+index 97a8d2d..fb4aadb 100644
+--- a/include/config.h.in
++++ b/include/config.h.in
+@@ -72,9 +72,6 @@
+ /* Define to 1 if you have the <unistd.h> header file. */
+ #undef HAVE_UNISTD_H
+ 
+-/* Use IPv6 with libtirpc */
+-#undef INET6
+-
+ /* Use libxml2 tsd usage workaround */
+ #undef LIBXML2_WORKAROUND
+ 
+diff --git a/modules/replicated.c b/modules/replicated.c
+index b4f6da2..65634bd 100644
+--- a/modules/replicated.c
++++ b/modules/replicated.c
+@@ -180,7 +180,7 @@ static unsigned int get_proximity(struct sockaddr *host_addr)
+ 		break;
+ 
+ 	case AF_INET6:
+-#ifndef INET6
++#ifndef WITH_LIBTIRPC
+ 		return PROXIMITY_UNSUPPORTED;
+ #else
+ 		addr6 = (struct sockaddr_in6 *) host_addr;
+@@ -229,7 +229,9 @@ static unsigned int get_proximity(struct sockaddr *host_addr)
+ 			break;
+ 
+ 		case AF_INET6:
+-#ifdef INET6
++#ifndef WITH_LIBTIRPC
++			return PROXIMITY_UNSUPPORTED;
++#else
+ 			if (host_addr->sa_family == AF_INET)
+ 				break;
+ 
+@@ -309,7 +311,9 @@ static unsigned int get_proximity(struct sockaddr *host_addr)
+ 			break;
+ 
+ 		case AF_INET6:
+-#ifdef INET6
++#ifndef WITH_LIBTIRPC
++			return PROXIMITY_UNSUPPORTED;
++#else
+ 			if (host_addr->sa_family == AF_INET)
+ 				break;
+ 
Index: backfire/feeds/packages/utils/autofs/patches/118-autofs-5.0.6-add-piddir-to-configure.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/118-autofs-5.0.6-add-piddir-to-configure.patch
@@ -0,0 +1,159 @@
+autofs-5.0.5 - add piddir to configure
+
+From: Ian Kent <ikent@redhat.com>
+
+In order to accomodate possible changes or different pid file
+locations add directory selection for pid file directory to
+configure. Also update the fifo directory and flag file directory
+configure checks.
+---
+
+ CHANGELOG             |    1 +
+ Makefile.conf.in      |    3 +++
+ aclocal.m4            |   20 ++++++++++++++++++--
+ configure             |    4 ++--
+ redhat/Makefile       |    1 +
+ redhat/autofs.init.in |    4 ++--
+ samples/Makefile      |    2 +-
+ 7 files changed, 28 insertions(+), 7 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index 076830f..c2a7b1f 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -17,6 +17,7 @@
+ - fix ipv6 name lookup check.
+ - fix ipv6 rpc calls.
+ - fix ipv6 configure check.
++- add piddir to configure.
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/Makefile.conf.in b/Makefile.conf.in
+index 80093c1..f49dbd0 100644
+--- a/Makefile.conf.in
++++ b/Makefile.conf.in
+@@ -79,6 +79,9 @@ autofsconfdir = @confdir@
+ # Location for autofs maps
+ autofsmapdir = @mapdir@
+ 
++# Localtion of pid files
++autofspiddir = @piddir@
++
+ # Location for autofs fifos
+ autofsfifodir = @fifodir@
+ 
+diff --git a/aclocal.m4 b/aclocal.m4
+index e1e12f7..461801d 100644
+--- a/aclocal.m4
++++ b/aclocal.m4
+@@ -121,13 +121,29 @@ AC_DEFUN(AF_MAP_D,
+ fi])
+ 
+ dnl --------------------------------------------------------------------------
++dnl AF_PID_D
++dnl
++dnl Check the location of the pid file directory.
++dnl --------------------------------------------------------------------------
++AC_DEFUN(AF_PID_D,
++[if test -z "$piddir"; then
++  for pid_d in /run /var/run /tmp; do
++    if test -z "$piddir"; then
++      if test -d "$pid_d"; then
++        piddir="$pid_d"
++      fi
++    fi
++  done
++fi])
++
++dnl --------------------------------------------------------------------------
+ dnl AF_FIFO_D
+ dnl
+ dnl Check the location of the autofs fifos directory
+ dnl --------------------------------------------------------------------------
+ AC_DEFUN(AF_FIFO_D,
+ [if test -z "$fifodir"; then
+-  for fifo_d in /var/run /tmp; do
++  for fifo_d in /run /var/run /tmp; do
+     if test -z "$fifodir"; then
+       if test -d "$fifo_d"; then
+         fifodir="$fifo_d"
+@@ -143,7 +159,7 @@ dnl Check the location of the autofs flag file directory
+ dnl --------------------------------------------------------------------------
+ AC_DEFUN(AF_FLAG_D,
+ [if test -z "$flagdir"; then
+-  for flag_d in /var/run /tmp; do
++  for flag_d in /run /var/run /tmp; do
+     if test -z "$flagdir"; then
+       if test -d "$flag_d"; then
+         flagdir="$flag_d"
+diff --git a/configure b/configure
+index 62599a9..0d014c1 100755
+--- a/configure
++++ b/configure
+@@ -2184,7 +2184,7 @@ $as_echo "$mapdir" >&6; }
+ # The user can specify --with-fifodir=PATH to specify where autofs fifos go
+ #
+ if test -z "$fifodir"; then
+-  for fifo_d in /var/run /tmp; do
++  for fifo_d in /run /var/run /tmp; do
+     if test -z "$fifodir"; then
+       if test -d "$fifo_d"; then
+         fifodir="$fifo_d"
+@@ -2214,7 +2214,7 @@ $as_echo "$fifodir" >&6; }
+ # The user can specify --with-flagdir=PATH to specify where autofs flag file goes
+ #
+ if test -z "$flagdir"; then
+-  for flag_d in /var/run /tmp; do
++  for flag_d in /run /var/run /tmp; do
+     if test -z "$flagdir"; then
+       if test -d "$flag_d"; then
+         flagdir="$flag_d"
+diff --git a/redhat/Makefile b/redhat/Makefile
+index ea83719..b9ad209 100644
+--- a/redhat/Makefile
++++ b/redhat/Makefile
+@@ -8,6 +8,7 @@ autofs.init: autofs.init.in
+ 	sed -e "s|@@sbindir@@|$(sbindir)|g" \
+ 	    -e "s|@@autofslibdir@@|$(autofslibdir)|g" \
+ 	    -e "s|@@autofsconfdir@@|$(autofsconfdir)|g" \
++	    -e "s|@@autofspiddir@@|$(autofspiddir)|g" \
+ 	    -e "s|@@initdir@@|$(initdir)|g" < autofs.init.in > autofs.init
+ 
+ autofs.sysconfig: autofs.sysconfig.in
+diff --git a/redhat/autofs.init.in b/redhat/autofs.init.in
+index 48d387d..38b9eeb 100644
+--- a/redhat/autofs.init.in
++++ b/redhat/autofs.init.in
+@@ -86,7 +86,7 @@ function start() {
+ 	fi
+ 
+ 	echo -n $"Starting $prog: "
+-	$prog $OPTIONS --pid-file /var/run/autofs.pid
++	$prog $OPTIONS --pid-file @@autofspiddir@@/autofs.pid
+ 	RETVAL=$?
+ 	if [ $RETVAL -eq 0 ] ; then
+ 		success "$prog startup"
+@@ -171,7 +171,7 @@ case "$1" in
+ 		stop
+ 		;;
+ 	status)
+-		status -p /var/run/autofs.pid -l autofs $prog
++		status -p @@autofspiddir@@/autofs.pid -l autofs $prog
+ 		;;
+ 	restart|force-reload)
+ 		restart
+diff --git a/samples/Makefile b/samples/Makefile
+index 81f401d..2a6e898 100644
+--- a/samples/Makefile
++++ b/samples/Makefile
+@@ -21,7 +21,7 @@ dirs:
+ 	install -d -m 755 $(INSTALLROOT)$(autofsmapdir)
+ 	install -d -m 755 $(INSTALLROOT)$(autofsconfdir)
+ 	install -d -m 755 $(INSTALLROOT)$(autofslibdir)
+-	install -d -m 755 $(INSTALLROOT)/var/run/autofs
++	install -d -m 755 $(INSTALLROOT)$(autofspiddir)
+ 
+ .PHONY: autofs.init
+ autofs.init:
Index: backfire/feeds/packages/utils/autofs/patches/119-autofs-5.0.6-add-systemd-unit-support.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/119-autofs-5.0.6-add-systemd-unit-support.patch
@@ -0,0 +1,407 @@
+autofs-5.0.5 - add systemd unit support
+
+From: Ian Kent <ikent@redhat.com>
+
+Add a systemd unit file and attempt to integrating it into our
+install.
+---
+
+ CHANGELOG                 |    1 +
+ Makefile.conf.in          |    2 ++
+ aclocal.m4                |   28 ++++++++++++++++++++++
+ autofs.spec               |   58 ++++++++++++++++++++++++++++++++++++++++-----
+ configure                 |   47 ++++++++++++++++++++++++++++++++++++
+ configure.in              |    9 +++++++
+ redhat/Makefile           |   10 ++++++--
+ samples/Makefile          |   23 +++++++++++++-----
+ samples/autofs.service.in |   12 +++++++++
+ 9 files changed, 176 insertions(+), 14 deletions(-)
+ create mode 100644 samples/autofs.service.in
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index c2a7b1f..d951b5a 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -18,6 +18,7 @@
+ - fix ipv6 rpc calls.
+ - fix ipv6 configure check.
+ - add piddir to configure.
++- add systemd unit support.
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/Makefile.conf.in b/Makefile.conf.in
+index f49dbd0..fa4936d 100644
+--- a/Makefile.conf.in
++++ b/Makefile.conf.in
+@@ -98,3 +98,5 @@ mandir = @mandir@
+ # Location for init.d files
+ initdir = @initdir@
+ 
++# Location of systemd unit files
++systemddir = @systemddir@
+diff --git a/aclocal.m4 b/aclocal.m4
+index 461801d..7cfc7ef 100644
+--- a/aclocal.m4
++++ b/aclocal.m4
+@@ -199,6 +199,34 @@ fi], [AC_MSG_RESULT(no)])
+ ])
+ 
+ dnl --------------------------------------------------------------------------
++dnl AF_WITH_SYSTEMD
++dnl
++dnl Check the location of the systemd unit files directory
++dnl --------------------------------------------------------------------------
++AC_DEFUN([AF_WITH_SYSTEMD],
++[AC_ARG_WITH(systemd,
++[  --with-systemd         install systemd unit file if systemd unit directory
++			  is found on system],
++[if test "$withval" = yes; then
++  if test -z "$systemddir"; then
++    AC_MSG_CHECKING([location of the systemd unit files directory])
++    for systemd_d in /lib/systemd/system; do
++      if test -z "$systemddir"; then
++        if test -d "$systemd_d"; then
++          systemddir="$systemd_d"
++        fi
++      fi
++    done
++  fi
++  if test -n "$systemddir"; then
++    AC_MSG_RESULT($systemddir)
++  else
++    AC_MSG_RESULT(not found)
++  fi
++fi])
++])
++
++dnl --------------------------------------------------------------------------
+ dnl AF_CHECK_LIBXML
+ dnl
+ dnl Check for lib xml
+diff --git a/autofs.spec b/autofs.spec
+index 510ef76..d854b1f 100644
+--- a/autofs.spec
++++ b/autofs.spec
+@@ -8,6 +8,10 @@
+ %define _lib lib64
+ %endif
+ 
++# Use --without systemd in your rpmbuild command or force values to 0 to
++# disable them.
++%define with_systemd        %{?_without_systemd:        0} %{?!_without_systemd:        1}
++
+ Summary: A tool from automatically mounting and umounting filesystems.
+ Name: autofs
+ %define version 5.0.6
+@@ -18,9 +22,18 @@ License: GPL
+ Group: System Environment/Daemons
+ Source: ftp://ftp.kernel.org/pub/linux/daemons/autofs/v4/autofs-%{version}.tar.gz
+ Buildroot: %{_tmppath}/%{name}-tmp
++%if %{with_systemd}
++BuildRequires: systemd-units
++%endif
+ BuildPrereq: autoconf, hesiod-devel, openldap-devel, bison, flex, cyrus-sasl-devel
+ Prereq: chkconfig
+ Requires: /bin/bash mktemp sed textutils sh-utils grep /bin/ps
++%if %{with_systemd}
++Requires(post): systemd-sysv
++Requires(post): systemd-units
++Requires(preun): systemd-units
++Requires(postun): systemd-units
++%endif
+ Obsoletes: autofs-ldap
+ Summary(de): autofs daemon 
+ Summary(fr): dmon autofs
+@@ -55,14 +68,22 @@ inkludera n
+ %prep
+ %setup -q
+ echo %{version}-%{release} > .version
++%if %{with_systemd}
++  %define _unitdir %{?_unitdir:/lib/systemd/system}
++  %define systemd_configure_arg --with-systemd
++%endif
+ 
+ %build
+-CFLAGS="$RPM_OPT_FLAGS -Wall" ./configure --libdir=%{_libdir} --disable-mount-locking --enable-ignore-busy --with-libtirpc --disable-mount-move
++CFLAGS="$RPM_OPT_FLAGS -Wall" ./configure --libdir=%{_libdir} --disable-mount-locking --enable-ignore-busy --with-libtirpc --disable-mount-move %{?systemd_configure_arg:}
+ CFLAGS="$RPM_OPT_FLAGS -Wall" make initdir=/etc/rc.d/init.d DONTSTRIP=1
+ 
+ %install
+ rm -rf $RPM_BUILD_ROOT
++%if %{with_systemd}
++install -d -m 755 $RPM_BUILD_ROOT%{_unitdir}
++%else
+ mkdir -p -m755 $RPM_BUILD_ROOT/etc/rc.d/init.d
++%endif
+ mkdir -p -m755 $RPM_BUILD_ROOT%{_sbindir}
+ mkdir -p -m755 $RPM_BUILD_ROOT%{_libdir}/autofs
+ mkdir -p -m755 $RPM_BUILD_ROOT%{_mandir}/{man5,man8}
+@@ -70,31 +91,56 @@ mkdir -p -m755 $RPM_BUILD_ROOT/etc/sysconfig
+ mkdir -p -m755 $RPM_BUILD_ROOT/etc/auto.master.d
+ 
+ make install mandir=%{_mandir} initdir=/etc/rc.d/init.d INSTALLROOT=$RPM_BUILD_ROOT
++echo make -C redhat
+ make -C redhat
++%if %{with_systemd}
++install -m 644 redhat/autofs.service $RPM_BUILD_ROOT%{_unitdir}/autofs.service
++%else
+ install -m 755 redhat/autofs.init $RPM_BUILD_ROOT/etc/rc.d/init.d/autofs
++%endif
+ install -m 644 redhat/autofs.sysconfig $RPM_BUILD_ROOT/etc/sysconfig/autofs
+ 
+ %clean
+ [ "$RPM_BUILD_ROOT" != "/" ] && rm -rf $RPM_BUILD_ROOT
+ 
+ %post
++%if %{with_systemd}
++/bin/systemctl daemon-reload >/dev/null 2>&1 || :
++%else
+ chkconfig --add autofs
+-
+-%postun
+-if [ $1 -ge 1 ] ; then
+-	/sbin/service autofs condrestart > /dev/null 2>&1 || :
+-fi
++%endif
+ 
+ %preun
+ if [ "$1" = 0 ] ; then
++%if %{with_systemd}
++	/bin/systemctl --no-reload disable autofs.service > /dev/null 2>&1 || :
++	/bin/systemctl stop autofs.service > /dev/null 2>&1 || :
++%else
+ 	/sbin/service autofs stop > /dev/null 2>&1 || :
+ 	/sbin/chkconfig --del autofs
++%endif
+ fi
+ 
++%postun
++%if %{with_systemd}
++/bin/systemctl daemon-reload >/dev/null 2>&1 || :
++if [ $1 -ge 1 ] ; then
++	/bin/systemctl try-restart autofs.service >/dev/null 2>&1 || :
++fi
++%else
++if [ $1 -ge 1 ] ; then
++	/sbin/service autofs condrestart > /dev/null 2>&1 || :
++fi
++%endif
++
+ %files
+ %defattr(-,root,root)
+ %doc CREDITS CHANGELOG INSTALL COPY* README* samples/ldap* samples/autofs.schema samples/autofs_ldap_auth.conf
++%if %{with_systemd}
++%{_unitdir}/autofs.service
++%else
+ %config /etc/rc.d/init.d/autofs
++%endif
+ %config(noreplace) /etc/auto.master
+ %config(noreplace,missingok) /etc/auto.misc
+ %config(noreplace,missingok) /etc/auto.net
+diff --git a/configure b/configure
+index 0d014c1..86a0d74 100755
+--- a/configure
++++ b/configure
+@@ -650,6 +650,8 @@ flagdir
+ fifodir
+ mapdir
+ confdir
++systemddir
++piddir
+ initdir
+ target_alias
+ host_alias
+@@ -693,6 +695,7 @@ ac_subst_files=''
+ ac_user_opts='
+ enable_option_checking
+ with_path
++with_systemd
+ with_confdir
+ with_mapdir
+ with_fifodir
+@@ -1337,6 +1340,8 @@ Optional Packages:
+   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
+   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+   --with-path=PATH	  look in PATH for binaries needed by the automounter
++  --with-systemd         install systemd unit file if systemd unit directory
++			  is found on system
+   --with-confdir=DIR	  use DIR for autofs configuration files
+   --with-mapdir=PATH	  look in PATH for mount maps used by the automounter
+   --with-fifodir=PATH	   use PATH as the directory for fifos used by the automounter
+@@ -2119,6 +2124,48 @@ $as_echo "$initdir" >&6; }
+   done
+ fi
+ 
++if test -z "$piddir"; then
++  for pid_d in /run /var/run /tmp; do
++    if test -z "$piddir"; then
++      if test -d "$pid_d"; then
++        piddir="$pid_d"
++      fi
++    fi
++  done
++fi
++
++
++#
++# Check for systemd unit files direectory exists if unit file installation
++# is requested
++#
++
++# Check whether --with-systemd was given.
++if test "${with_systemd+set}" = set; then :
++  withval=$with_systemd; if test "$withval" = yes; then
++  if test -z "$systemddir"; then
++    { $as_echo "$as_me:${as_lineno-$LINENO}: checking location of the systemd unit files directory" >&5
++$as_echo_n "checking location of the systemd unit files directory... " >&6; }
++    for systemd_d in /lib/systemd/system; do
++      if test -z "$systemddir"; then
++        if test -d "$systemd_d"; then
++          systemddir="$systemd_d"
++        fi
++      fi
++    done
++  fi
++  if test -n "$systemddir"; then
++    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $systemddir" >&5
++$as_echo "$systemddir" >&6; }
++  else
++    { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
++$as_echo "not found" >&6; }
++  fi
++fi
++fi
++
++
++
+ 
+ #
+ # Location of system config script directory?
+diff --git a/configure.in b/configure.in
+index d3e4e54..05ee67f 100644
+--- a/configure.in
++++ b/configure.in
+@@ -43,6 +43,15 @@ AF_LINUX_PROCFS()
+ #
+ AF_INIT_D()
+ AC_SUBST(initdir)
++AF_PID_D()
++AC_SUBST(piddir)
++
++#
++# Check for systemd unit files direectory exists if unit file installation
++# is requested
++#
++AF_WITH_SYSTEMD()
++AC_SUBST(systemddir)
+ 
+ #
+ # Location of system config script directory?
+diff --git a/redhat/Makefile b/redhat/Makefile
+index b9ad209..d9b9101 100644
+--- a/redhat/Makefile
++++ b/redhat/Makefile
+@@ -2,7 +2,7 @@
+ -include ../Makefile.conf
+ include ../Makefile.rules
+ 
+-all: autofs.init autofs.sysconfig
++all: autofs.init autofs.sysconfig autofs.service
+ 
+ autofs.init: autofs.init.in
+ 	sed -e "s|@@sbindir@@|$(sbindir)|g" \
+@@ -15,6 +15,12 @@ autofs.sysconfig: autofs.sysconfig.in
+ 	sed -e "s|@@autofsmapdir@@|$(autofsmapdir)|g" \
+ 		< autofs.sysconfig.in > autofs.sysconfig
+ 
++autofs.service: ../samples/autofs.service.in
++	sed -e "s|@@sbindir@@|$(sbindir)|g" \
++	    -e "s|@@autofsconfdir@@|$(autofsconfdir)|g" \
++	    -e "s|@@autofspiddir@@|$(autofspiddir)|g" \
++		< ../samples/autofs.service.in > autofs.service
++
+ clean:
+-	rm -f autofs.init autofs.sysconfig
++	rm -f autofs.init autofs.sysconfig autofs.service
+ 
+diff --git a/samples/Makefile b/samples/Makefile
+index 2a6e898..91c1d6b 100644
+--- a/samples/Makefile
++++ b/samples/Makefile
+@@ -4,7 +4,7 @@ include ../Makefile.rules
+ 
+ SAMPLES = auto.master auto.misc auto.net auto.smb
+ 
+-all: rc.autofs autofs.conf.default
++all: rc.autofs autofs.conf.default autofs.service
+ 
+ rc.autofs: rc.autofs.in
+ 	sed -e "s|@@sbindir@@|$(sbindir)|g" \
+@@ -16,6 +16,12 @@ autofs.conf.default: autofs.conf.default.in
+ 	sed -e "s|@@autofsmapdir@@|$(autofsmapdir)|g" \
+ 		< autofs.conf.default.in > autofs.conf.default
+ 
++autofs.service: autofs.service.in
++	sed -e "s|@@sbindir@@|$(sbindir)|g" \
++	    -e "s|@@autofsconfdir@@|$(autofsconfdir)|g" \
++	    -e "s|@@autofspiddir@@|$(autofspiddir)|g" \
++		< autofs.service.in > autofs.service
++
+ .PHONY: dirs
+ dirs:
+ 	install -d -m 755 $(INSTALLROOT)$(autofsmapdir)
+@@ -26,13 +32,18 @@ dirs:
+ .PHONY: autofs.init
+ autofs.init:
+ 	@echo
+-ifneq ($(initdir),)
++ifneq ($(systemddir),)
++	install -d -m 755 $(INSTALLROOT)$(systemddir)
++	install autofs.service -m 644 $(INSTALLROOT)$(systemddir)/autofs.service
++else
++   ifneq ($(initdir),)
+ 	install -d -m 755 $(INSTALLROOT)$(initdir)
+ 	install rc.autofs -m 755 $(INSTALLROOT)$(initdir)/autofs
+-else
++   else
+ 	if test -d $(INSTALLROOT)/etc/rc.d ; then \
+ 		install -c rc.autofs -m 755 $(INSTALLROOT)/etc/rc.d ; \
+ 	fi
++   endif
+ endif
+ 
+ CONFIG = $(shell test -e $(INSTALLROOT)$(autofsconfdir)/autofs.orig || echo "-b --suffix=.orig")
+@@ -173,10 +184,10 @@ auto.smb:
+ 		fi ; \
+ 	fi
+ 
+-install: rc.autofs autofs.conf.default dirs autofs.init autofs.conf \
+-		autofs_ldap_auth.conf $(SAMPLES)
++install: rc.autofs autofs.conf.default dirs autofs.init autofs.service \
++		autofs.conf autofs_ldap_auth.conf $(SAMPLES)
+ 	@echo
+ 
+ clean:
+-	rm -f *.o *.s rc.autofs autofs.conf.default
++	rm -f *.o *.s rc.autofs autofs.conf.default autofs.service
+ 
+diff --git a/samples/autofs.service.in b/samples/autofs.service.in
+new file mode 100644
+index 0000000..3756078
+--- /dev/null
++++ b/samples/autofs.service.in
+@@ -0,0 +1,12 @@
++[Unit]
++Description=Automounts filesystems on demand
++After=network.target ypbind.service
++
++[Service]
++Type=forking
++PIDFile=@@autofspiddir@@/autofs.pid
++EnvironmentFile=-@@autofsconfdir@@/autofs
++ExecStart=@@sbindir@@/automount ${OPTIONS} --pid-file @@autofspiddir@@/autofs.pid
++
++[Install]
++WantedBy=multi-user.target
Index: backfire/feeds/packages/utils/autofs/patches/120-autofs-5.0.6-fix-MNT_DETACH-define.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/120-autofs-5.0.6-fix-MNT_DETACH-define.patch
@@ -0,0 +1,25 @@
+autofs-5.0.6 - fix MNT_DETACH define
+
+From: Ian Kent <raven@themaw.net>
+
+MNT_DETACH has been included in herder file
+---
+
+ include/automount.h |    2 ++
+ 1 files changed, 2 insertions(+), 0 deletions(-)
+
+
+diff --git a/include/automount.h b/include/automount.h
+index 8816c15..4291bbd 100644
+--- a/include/automount.h
++++ b/include/automount.h
+@@ -333,7 +333,9 @@ int ncat_path(char *buf, size_t len,
+ 
+ /* Core automount definitions */
+ 
++#ifndef MNT_DETACH
+ #define MNT_DETACH	0x00000002	/* Just detach from the tree */
++#endif
+ 
+ struct startup_cond {
+ 	pthread_mutex_t mutex;
Index: backfire/feeds/packages/utils/autofs/patches/121-autofs-5.0.6-remove-empty-command-line-arguments.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/121-autofs-5.0.6-remove-empty-command-line-arguments.patch
@@ -0,0 +1,117 @@
+autofs-5.0.6 - remove empty command line arguments
+
+From: Ian Kent <raven@themaw.net>
+
+When invoking the automount daemon from a systemd unit file a macro
+that evaluates to the empty string is passed as an empty argument
+unlike the shell environment within which unquoted arguments are
+seen as white space and are not passed at all.
+
+These empty arguments confuse getopt(3) and cause the program
+parameters to be misread so we need to remove them before calling
+getopt(3).
+---
+
+ CHANGELOG          |    1 +
+ daemon/automount.c |   39 +++++++++++++++++++++++++++++++++++----
+ 2 files changed, 36 insertions(+), 4 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index d951b5a..8dec17f 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -19,6 +19,7 @@
+ - fix ipv6 configure check.
+ - add piddir to configure.
+ - add systemd unit support.
++- remove empty command line arguments (passed by systemd).
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/daemon/automount.c b/daemon/automount.c
+index 6bb5aa8..c0b4b85 100644
+--- a/daemon/automount.c
++++ b/daemon/automount.c
+@@ -1865,6 +1865,34 @@ static int convert_log_priority(char *priority_name)
+ 	return -1;
+ }
+ 
++static void remove_empty_args(char **argv, int *argc)
++{
++	int next_to_last = *argc - 1;
++	int i, j;
++
++	for (i = j = 1; i < *argc; i++) {
++		if (*argv[i]) {
++			j++;
++			continue;
++		}
++
++		while (i < *argc && argv[i] && !*argv[i]) i++;
++
++		if (i == *argc)
++			break;
++
++		if (i == next_to_last) {
++			if (*argv[i])
++				argv[j++] = argv[i];
++			break;
++		} else {
++			argv[j++] = argv[i];
++			argv[i--] = "";
++		}
++	}
++	*argc = j;
++}
++
+ int main(int argc, char *argv[])
+ {
+ 	int res, opt, status;
+@@ -1874,6 +1902,7 @@ int main(int argc, char *argv[])
+ 	time_t timeout;
+ 	time_t age = time(NULL);
+ 	struct rlimit rlim;
++	const char *options = "+hp:t:vmdD:fVrO:l:n:CF";
+ 	static const struct option long_options[] = {
+ 		{"help", 0, 0, 'h'},
+ 		{"pid-file", 1, 0, 'p'},
+@@ -1918,8 +1947,10 @@ int main(int argc, char *argv[])
+ 	dumpmaps = 0;
+ 	daemon_check = 1;
+ 
++	remove_empty_args(argv, &argc);
++
+ 	opterr = 0;
+-	while ((opt = getopt_long(argc, argv, "+hp:t:vmdD:fVrO:l:n:CF", long_options, NULL)) != EOF) {
++	while ((opt = getopt_long(argc, argv, options, long_options, NULL)) != EOF) {
+ 		switch (opt) {
+ 		case 'h':
+ 			usage();
+@@ -2066,7 +2097,7 @@ int main(int argc, char *argv[])
+ 	res = setrlimit(RLIMIT_NOFILE, &rlim);
+ 	if (res)
+ 		printf("%s: can't increase open file limit - continuing",
+-			argv[0]);
++			program);
+ 
+ #if ENABLE_CORES
+ 	rlim.rlim_cur = RLIM_INFINITY;
+@@ -2074,7 +2105,7 @@ int main(int argc, char *argv[])
+ 	res = setrlimit(RLIMIT_CORE, &rlim);
+ 	if (res)
+ 		printf("%s: can't increase core file limit - continuing",
+-			argv[0]);
++			program);
+ #endif
+ 
+ 	if (argc == 0)
+@@ -2097,7 +2128,7 @@ int main(int argc, char *argv[])
+ 		nc = cache_init_null_cache(master_list);
+ 		if (!nc) {
+ 			printf("%s: failed to init null map cache for %s",
+-				master_list->name, argv[0]);
++				program, master_list->name);
+ 			exit(1);
+ 		}
+ 		master_list->nc = nc;
Index: backfire/feeds/packages/utils/autofs/patches/122-autofs-5.0.6-fix-rpc-build-error.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/122-autofs-5.0.6-fix-rpc-build-error.patch
@@ -0,0 +1,39 @@
+autofs-5.0.6 - fix rpc build error
+
+From: Leonardo Chiquitto <leonardo.lists@gmail.com>
+
+The compile error looks like a problem in the libtirpc interface code rewrite
+(commit f8ea2a5762 - autofs-5.0.6 - fix ipv6 rpc calls). The following patch
+should fix it.
+---
+
+ CHANGELOG      |    1 +
+ lib/rpc_subs.c |    2 +-
+ 2 files changed, 2 insertions(+), 1 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index 8dec17f..11d2cbf 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -20,6 +20,7 @@
+ - add piddir to configure.
+ - add systemd unit support.
+ - remove empty command line arguments (passed by systemd).
++- fix rpc build error.
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/lib/rpc_subs.c b/lib/rpc_subs.c
+index ba679a5..4082fee 100644
+--- a/lib/rpc_subs.c
++++ b/lib/rpc_subs.c
+@@ -154,7 +154,7 @@ static CLIENT *rpc_do_create_client(struct sockaddr *addr, struct conn_info *inf
+ {
+ 	CLIENT *client = NULL;
+ 	struct sockaddr_in in4_laddr;
+-	struct sockaddr_in in4_raddr;
++	struct sockaddr_in *in4_raddr;
+ 	int type, proto;
+ 	socklen_t slen;
+ 
Index: backfire/feeds/packages/utils/autofs/patches/123-autofs-5.0.6-fix-improve-mount-location-error-reporting.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/123-autofs-5.0.6-fix-improve-mount-location-error-reporting.patch
@@ -0,0 +1,53 @@
+autofs-5.0.6 - fix improve mount location error reporting
+
+From: Ian Kent <raven@themaw.net>
+
+The validate_location() function is meant to check for a small subset
+of map location errors only but the "improve mount location error
+reporting" patch inverted a logic test which has made the scope of
+the test greater causing false positive fails. So add a check for
+those special cases and return success instead.
+---
+
+ CHANGELOG           |    1 +
+ modules/parse_sun.c |   14 ++++++++++++++
+ 2 files changed, 15 insertions(+), 0 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index 11d2cbf..b6802b9 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -21,6 +21,7 @@
+ - add systemd unit support.
+ - remove empty command line arguments (passed by systemd).
+ - fix rpc build error.
++- fix improve mount location error reporting.
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/modules/parse_sun.c b/modules/parse_sun.c
+index 13b8af8..e9d94c7 100644
+--- a/modules/parse_sun.c
++++ b/modules/parse_sun.c
+@@ -868,6 +868,20 @@ static int validate_location(unsigned int logopt, char *loc)
+ 	 * have ":", "[" and "]".
+ 	 */
+ 	if (!check_colon(ptr)) {
++		char *esc;
++		/*
++		 * Don't forget cases where a colon is present but
++		 * not followed by a "/" or, if there is no colon at
++		 * all, we don't know if it is actually invalid since
++		 * it may be a map name by itself, for example.
++		 */
++		if (!strchr(ptr, ':') ||
++		    ((esc = strchr(ptr, '\\')) && *(esc + 1) == ':') ||
++		    !strncmp(ptr, "file:", 5) || !strncmp(ptr, "yp:", 3) ||
++		    !strncmp(ptr, "nis:", 4) || !strncmp(ptr, "nisplus:", 8) ||
++		    !strncmp(ptr, "ldap:", 5) || !strncmp(ptr, "ldaps:", 6) ||
++		    !strncmp(ptr, "dir:", 4))
++			return 1;
+ 		error(logopt,
+ 		      "expected colon delimeter not found in location %s",
+ 		      loc);
Index: backfire/feeds/packages/utils/autofs/patches/124-autofs-5.0.6-fix-fix-wait-for-master-source-mutex.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/124-autofs-5.0.6-fix-fix-wait-for-master-source-mutex.patch
@@ -0,0 +1,43 @@
+autofs-5.0.6 - fix fix wait for master source mutex
+
+From: Ian Kent <raven@themaw.net>
+
+The "wait for master source mutex" change wait for a busy read/write
+mutex to become available instead of failing. The s390x architecture
+is slower than the Intel architectures and the time allowed to wait
+can be too short leading to a failure anyway.
+
+This patch increases the maximum wait from 1 second to 5 seconds to
+avoid false positive fails.
+---
+
+ CHANGELOG    |    1 +
+ lib/master.c |    2 +-
+ 2 files changed, 2 insertions(+), 1 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index b6802b9..918d35b 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -22,6 +22,7 @@
+ - remove empty command line arguments (passed by systemd).
+ - fix rpc build error.
+ - fix improve mount location error reporting.
++- fix fix wait for master source mutex.
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/lib/master.c b/lib/master.c
+index 87d1269..aad9087 100644
+--- a/lib/master.c
++++ b/lib/master.c
+@@ -552,7 +552,7 @@ void master_source_writelock(struct master_mapent *entry)
+ 
+ void master_source_readlock(struct master_mapent *entry)
+ {
+-	int retries = 5; /* 1 second maximum */
++	int retries = 25; /* 5 second maximum */
+ 	int status;
+ 
+ 	while (retries--) {
Index: backfire/feeds/packages/utils/autofs/patches/125-autofs-5.0.6-add-sss-lookup-module.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/125-autofs-5.0.6-add-sss-lookup-module.patch
@@ -0,0 +1,1691 @@
+autofs-5.0.6 - add sss lookup module
+
+From: Ian Kent <raven@themaw.net>
+
+Add a lookup module (initial implementation) to handle lookups for
+an sssd source.
+
+The % hack for mixed case map keys present in case insensitive schema
+still needs to be implemented.
+---
+
+ CHANGELOG            |    1 
+ Makefile.conf.in     |    6 
+ aclocal.m4           |   24 ++
+ configure            |  238 ++++++++++--------
+ configure.in         |    4 
+ modules/Makefile     |    6 
+ modules/lookup_sss.c |  678 ++++++++++++++++++++++++++++++++++++++++++++++++++
+ 7 files changed, 860 insertions(+), 97 deletions(-)
+ create mode 100644 modules/lookup_sss.c
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index 918d35b..ba6f90c 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -23,6 +23,7 @@
+ - fix rpc build error.
+ - fix improve mount location error reporting.
+ - fix fix wait for master source mutex.
++- add sss lookup module.
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/Makefile.conf.in b/Makefile.conf.in
+index fa4936d..802318b 100644
+--- a/Makefile.conf.in
++++ b/Makefile.conf.in
+@@ -25,6 +25,9 @@ LDAP = @HAVE_LDAP@
+ LIBLDAP= @LIBLDAP@
+ LDAP_FLAGS = @LDAP_FLAGS@
+ 
++# sssd support
++SSSD = @HAVE_SSS_AUTOFS@
++
+ # SASL support: yes (1) no (0)
+ XML_LIBS = @XML_LIBS@
+ XML_FLAGS = @XML_FLAGS@
+@@ -70,6 +73,9 @@ DMALLOCLIB = @DMALLOCLIB@
+ prefix = @prefix@
+ exec_prefix = @exec_prefix@
+ 
++# SSS library module directory
++ssslibdir=@sssldir@
++
+ # Directory for autofs modules
+ autofslibdir = @libdir@/autofs
+ 
+diff --git a/aclocal.m4 b/aclocal.m4
+index 7cfc7ef..439d56f 100644
+--- a/aclocal.m4
++++ b/aclocal.m4
+@@ -32,6 +32,30 @@ fi
+ AC_SUBST(PATH_$1)])
+ 
+ dnl --------------------------------------------------------------------------
++dnl AF_CHECK_SSS_LIB:
++dnl
++dnl Check if a sss autofs library exists.
++dnl --------------------------------------------------------------------------
++AC_DEFUN(AF_CHECK_SSS_LIB,
++[if test -z $sssldir; then
++  AC_MSG_CHECKING(for sssd autofs library)
++  for libd in /usr/lib64 /usr/lib; do
++    if test -z $sssldir; then
++      if test -e "$libd/sssd/modules/$2"; then
++        sssldir=$libd/sssd/modules
++      fi
++    fi
++  done
++  if test -n $sssldir; then
++    HAVE_$1=1
++    AC_MSG_RESULT(yes)
++  else
++    HAVE_$1=0
++    AC_MSG_RESULT(no)
++  fi
++fi])
++
++dnl --------------------------------------------------------------------------
+ dnl AF_SLOPPY_MOUNT
+ dnl
+ dnl Check to see if mount(8) supports the sloppy (-s) option, and define
+diff --git a/configure b/configure
+index 86a0d74..f78b322 100755
+--- a/configure
++++ b/configure
+@@ -1,6 +1,6 @@
+ #! /bin/sh
+ # Guess values for system-dependent variables and create Makefiles.
+-# Generated by GNU Autoconf 2.66.
++# Generated by GNU Autoconf 2.68.
+ #
+ #
+ # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
+@@ -89,6 +89,7 @@ fi
+ IFS=" ""	$as_nl"
+ 
+ # Find who we are.  Look in the path if we contain no directory separator.
++as_myself=
+ case $0 in #((
+   *[\\/]* ) as_myself=$0 ;;
+   *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+@@ -214,11 +215,18 @@ IFS=$as_save_IFS
+   # We cannot yet assume a decent shell, so we have to provide a
+ 	# neutralization value for shells without unset; and this also
+ 	# works around shells that cannot unset nonexistent variables.
++	# Preserve -v and -x to the replacement shell.
+ 	BASH_ENV=/dev/null
+ 	ENV=/dev/null
+ 	(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
+ 	export CONFIG_SHELL
+-	exec "$CONFIG_SHELL" "$as_myself" ${1+"$@"}
++	case $- in # ((((
++	  *v*x* | *x*v* ) as_opts=-vx ;;
++	  *v* ) as_opts=-v ;;
++	  *x* ) as_opts=-x ;;
++	  * ) as_opts= ;;
++	esac
++	exec "$CONFIG_SHELL" $as_opts "$as_myself" ${1+"$@"}
+ fi
+ 
+     if test x$as_have_required = xno; then :
+@@ -617,6 +625,8 @@ LIBRESOLV
+ LIBNSL
+ KRB5_CONFIG
+ XML_CONFIG
++sssldir
++HAVE_SSS_AUTOFS
+ PATH_RPCGEN
+ RPCGEN
+ PATH_RANLIB
+@@ -782,8 +792,9 @@ do
+   fi
+ 
+   case $ac_option in
+-  *=*)	ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
+-  *)	ac_optarg=yes ;;
++  *=?*) ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
++  *=)   ac_optarg= ;;
++  *)    ac_optarg=yes ;;
+   esac
+ 
+   # Accept the important Cygnus configure options, so we can diagnose typos.
+@@ -1123,7 +1134,7 @@ Try \`$0 --help' for more information"
+     $as_echo "$as_me: WARNING: you should use --build, --host, --target" >&2
+     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+       $as_echo "$as_me: WARNING: invalid host type: $ac_option" >&2
+-    : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
++    : "${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}"
+     ;;
+ 
+   esac
+@@ -1430,7 +1441,7 @@ test -n "$ac_init_help" && exit $ac_status
+ if $ac_init_version; then
+   cat <<\_ACEOF
+ configure
+-generated by GNU Autoconf 2.66
++generated by GNU Autoconf 2.68
+ 
+ Copyright (C) 2010 Free Software Foundation, Inc.
+ This configure script is free software; the Free Software Foundation
+@@ -1476,7 +1487,7 @@ sed 's/^/| /' conftest.$ac_ext >&5
+ 
+ 	ac_retval=1
+ fi
+-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
++  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+   as_fn_set_status $ac_retval
+ 
+ } # ac_fn_c_try_compile
+@@ -1522,7 +1533,7 @@ fi
+   # interfere with the next link command; also delete a directory that is
+   # left behind by Apple's compiler.  We do this before executing the actions.
+   rm -rf conftest.dSYM conftest_ipa8_conftest.oo
+-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
++  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+   as_fn_set_status $ac_retval
+ 
+ } # ac_fn_c_try_link
+@@ -1548,7 +1559,7 @@ $as_echo "$ac_try_echo"; } >&5
+     mv -f conftest.er1 conftest.err
+   fi
+   $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+-  test $ac_status = 0; } >/dev/null && {
++  test $ac_status = 0; } > conftest.i && {
+ 	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+ 	 test ! -s conftest.err
+        }; then :
+@@ -1559,7 +1570,7 @@ sed 's/^/| /' conftest.$ac_ext >&5
+ 
+     ac_retval=1
+ fi
+-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
++  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+   as_fn_set_status $ac_retval
+ 
+ } # ac_fn_c_try_cpp
+@@ -1572,10 +1583,10 @@ fi
+ ac_fn_c_check_header_mongrel ()
+ {
+   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+-  if eval "test \"\${$3+set}\"" = set; then :
++  if eval \${$3+:} false; then :
+   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+ $as_echo_n "checking for $2... " >&6; }
+-if eval "test \"\${$3+set}\"" = set; then :
++if eval \${$3+:} false; then :
+   $as_echo_n "(cached) " >&6
+ fi
+ eval ac_res=\$$3
+@@ -1611,7 +1622,7 @@ if ac_fn_c_try_cpp "$LINENO"; then :
+ else
+   ac_header_preproc=no
+ fi
+-rm -f conftest.err conftest.$ac_ext
++rm -f conftest.err conftest.i conftest.$ac_ext
+ { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_preproc" >&5
+ $as_echo "$ac_header_preproc" >&6; }
+ 
+@@ -1638,7 +1649,7 @@ $as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
+ esac
+   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+ $as_echo_n "checking for $2... " >&6; }
+-if eval "test \"\${$3+set}\"" = set; then :
++if eval \${$3+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   eval "$3=\$ac_header_compiler"
+@@ -1647,7 +1658,7 @@ eval ac_res=\$$3
+ 	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+ $as_echo "$ac_res" >&6; }
+ fi
+-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
++  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+ 
+ } # ac_fn_c_check_header_mongrel
+ 
+@@ -1688,7 +1699,7 @@ sed 's/^/| /' conftest.$ac_ext >&5
+        ac_retval=$ac_status
+ fi
+   rm -rf conftest.dSYM conftest_ipa8_conftest.oo
+-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
++  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+   as_fn_set_status $ac_retval
+ 
+ } # ac_fn_c_try_run
+@@ -1702,7 +1713,7 @@ ac_fn_c_check_header_compile ()
+   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+ $as_echo_n "checking for $2... " >&6; }
+-if eval "test \"\${$3+set}\"" = set; then :
++if eval \${$3+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+@@ -1720,7 +1731,7 @@ fi
+ eval ac_res=\$$3
+ 	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+ $as_echo "$ac_res" >&6; }
+-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
++  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+ 
+ } # ac_fn_c_check_header_compile
+ cat >config.log <<_ACEOF
+@@ -1728,7 +1739,7 @@ This file contains any messages produced by compilers while
+ running configure, to aid debugging if configure makes a mistake.
+ 
+ It was created by $as_me, which was
+-generated by GNU Autoconf 2.66.  Invocation command line was
++generated by GNU Autoconf 2.68.  Invocation command line was
+ 
+   $ $0 $@
+ 
+@@ -2300,7 +2311,7 @@ if test -n "$ac_tool_prefix"; then
+ set dummy ${ac_tool_prefix}gcc; ac_word=$2
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+ $as_echo_n "checking for $ac_word... " >&6; }
+-if test "${ac_cv_prog_CC+set}" = set; then :
++if ${ac_cv_prog_CC+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   if test -n "$CC"; then
+@@ -2340,7 +2351,7 @@ if test -z "$ac_cv_prog_CC"; then
+ set dummy gcc; ac_word=$2
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+ $as_echo_n "checking for $ac_word... " >&6; }
+-if test "${ac_cv_prog_ac_ct_CC+set}" = set; then :
++if ${ac_cv_prog_ac_ct_CC+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   if test -n "$ac_ct_CC"; then
+@@ -2393,7 +2404,7 @@ if test -z "$CC"; then
+ set dummy ${ac_tool_prefix}cc; ac_word=$2
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+ $as_echo_n "checking for $ac_word... " >&6; }
+-if test "${ac_cv_prog_CC+set}" = set; then :
++if ${ac_cv_prog_CC+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   if test -n "$CC"; then
+@@ -2433,7 +2444,7 @@ if test -z "$CC"; then
+ set dummy cc; ac_word=$2
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+ $as_echo_n "checking for $ac_word... " >&6; }
+-if test "${ac_cv_prog_CC+set}" = set; then :
++if ${ac_cv_prog_CC+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   if test -n "$CC"; then
+@@ -2492,7 +2503,7 @@ if test -z "$CC"; then
+ set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+ $as_echo_n "checking for $ac_word... " >&6; }
+-if test "${ac_cv_prog_CC+set}" = set; then :
++if ${ac_cv_prog_CC+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   if test -n "$CC"; then
+@@ -2536,7 +2547,7 @@ do
+ set dummy $ac_prog; ac_word=$2
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+ $as_echo_n "checking for $ac_word... " >&6; }
+-if test "${ac_cv_prog_ac_ct_CC+set}" = set; then :
++if ${ac_cv_prog_ac_ct_CC+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   if test -n "$ac_ct_CC"; then
+@@ -2819,7 +2830,7 @@ rm -f conftest.$ac_ext conftest$ac_cv_exeext conftest.out
+ ac_clean_files=$ac_clean_files_save
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of object files" >&5
+ $as_echo_n "checking for suffix of object files... " >&6; }
+-if test "${ac_cv_objext+set}" = set; then :
++if ${ac_cv_objext+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+@@ -2870,7 +2881,7 @@ OBJEXT=$ac_cv_objext
+ ac_objext=$OBJEXT
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C compiler" >&5
+ $as_echo_n "checking whether we are using the GNU C compiler... " >&6; }
+-if test "${ac_cv_c_compiler_gnu+set}" = set; then :
++if ${ac_cv_c_compiler_gnu+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+@@ -2907,7 +2918,7 @@ ac_test_CFLAGS=${CFLAGS+set}
+ ac_save_CFLAGS=$CFLAGS
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
+ $as_echo_n "checking whether $CC accepts -g... " >&6; }
+-if test "${ac_cv_prog_cc_g+set}" = set; then :
++if ${ac_cv_prog_cc_g+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   ac_save_c_werror_flag=$ac_c_werror_flag
+@@ -2985,7 +2996,7 @@ else
+ fi
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $CC option to accept ISO C89" >&5
+ $as_echo_n "checking for $CC option to accept ISO C89... " >&6; }
+-if test "${ac_cv_prog_cc_c89+set}" = set; then :
++if ${ac_cv_prog_cc_c89+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   ac_cv_prog_cc_c89=no
+@@ -3183,7 +3194,7 @@ do
+ set dummy $ac_prog; ac_word=$2
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+ $as_echo_n "checking for $ac_word... " >&6; }
+-if test "${ac_cv_path_MOUNT+set}" = set; then :
++if ${ac_cv_path_MOUNT+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   case $MOUNT in
+@@ -3243,7 +3254,7 @@ do
+ set dummy $ac_prog; ac_word=$2
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+ $as_echo_n "checking for $ac_word... " >&6; }
+-if test "${ac_cv_path_UMOUNT+set}" = set; then :
++if ${ac_cv_path_UMOUNT+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   case $UMOUNT in
+@@ -3303,7 +3314,7 @@ do
+ set dummy $ac_prog; ac_word=$2
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+ $as_echo_n "checking for $ac_word... " >&6; }
+-if test "${ac_cv_path_E2FSCK+set}" = set; then :
++if ${ac_cv_path_E2FSCK+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   case $E2FSCK in
+@@ -3362,7 +3373,7 @@ do
+ set dummy $ac_prog; ac_word=$2
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+ $as_echo_n "checking for $ac_word... " >&6; }
+-if test "${ac_cv_path_E3FSCK+set}" = set; then :
++if ${ac_cv_path_E3FSCK+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   case $E3FSCK in
+@@ -3421,7 +3432,7 @@ do
+ set dummy $ac_prog; ac_word=$2
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+ $as_echo_n "checking for $ac_word... " >&6; }
+-if test "${ac_cv_path_E4FSCK+set}" = set; then :
++if ${ac_cv_path_E4FSCK+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   case $E4FSCK in
+@@ -3480,7 +3491,7 @@ do
+ set dummy $ac_prog; ac_word=$2
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+ $as_echo_n "checking for $ac_word... " >&6; }
+-if test "${ac_cv_path_MODPROBE+set}" = set; then :
++if ${ac_cv_path_MODPROBE+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   case $MODPROBE in
+@@ -3540,7 +3551,7 @@ do
+ set dummy $ac_prog; ac_word=$2
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+ $as_echo_n "checking for $ac_word... " >&6; }
+-if test "${ac_cv_path_LEX+set}" = set; then :
++if ${ac_cv_path_LEX+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   case $LEX in
+@@ -3596,7 +3607,7 @@ do
+ set dummy $ac_prog; ac_word=$2
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+ $as_echo_n "checking for $ac_word... " >&6; }
+-if test "${ac_cv_path_YACC+set}" = set; then :
++if ${ac_cv_path_YACC+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   case $YACC in
+@@ -3652,7 +3663,7 @@ do
+ set dummy $ac_prog; ac_word=$2
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+ $as_echo_n "checking for $ac_word... " >&6; }
+-if test "${ac_cv_path_RANLIB+set}" = set; then :
++if ${ac_cv_path_RANLIB+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   case $RANLIB in
+@@ -3708,7 +3719,7 @@ do
+ set dummy $ac_prog; ac_word=$2
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+ $as_echo_n "checking for $ac_word... " >&6; }
+-if test "${ac_cv_path_RPCGEN+set}" = set; then :
++if ${ac_cv_path_RPCGEN+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   case $RPCGEN in
+@@ -3759,6 +3770,29 @@ else
+ fi
+ 
+ 
++if test -z $sssldir; then
++  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for sssd autofs library" >&5
++$as_echo_n "checking for sssd autofs library... " >&6; }
++  for libd in /usr/lib64 /usr/lib; do
++    if test -z $sssldir; then
++      if test -e "$libd/sssd/modules/libsss_autofs.so"; then
++        sssldir=$libd/sssd/modules
++      fi
++    fi
++  done
++  if test -n $sssldir; then
++    HAVE_SSS_AUTOFS=1
++    { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
++$as_echo "yes" >&6; }
++  else
++    HAVE_SSS_AUTOFS=0
++    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
++$as_echo "no" >&6; }
++  fi
++fi
++
++
++
+ #
+ # Newer mounts have the -s (sloppy) option to ignore unknown options,
+ # good for portability
+@@ -3785,7 +3819,7 @@ do
+ set dummy $ac_prog; ac_word=$2
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+ $as_echo_n "checking for $ac_word... " >&6; }
+-if test "${ac_cv_path_XML_CONFIG+set}" = set; then :
++if ${ac_cv_path_XML_CONFIG+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   case $XML_CONFIG in
+@@ -3860,7 +3894,7 @@ do
+ set dummy $ac_prog; ac_word=$2
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+ $as_echo_n "checking for $ac_word... " >&6; }
+-if test "${ac_cv_path_KRB5_CONFIG+set}" = set; then :
++if ${ac_cv_path_KRB5_CONFIG+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   case $KRB5_CONFIG in
+@@ -3920,7 +3954,7 @@ fi
+ #
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for yp_match in -lnsl" >&5
+ $as_echo_n "checking for yp_match in -lnsl... " >&6; }
+-if test "${ac_cv_lib_nsl_yp_match+set}" = set; then :
++if ${ac_cv_lib_nsl_yp_match+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   ac_check_lib_save_LIBS=$LIBS
+@@ -3954,7 +3988,7 @@ LIBS=$ac_check_lib_save_LIBS
+ fi
+ { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_nsl_yp_match" >&5
+ $as_echo "$ac_cv_lib_nsl_yp_match" >&6; }
+-if test "x$ac_cv_lib_nsl_yp_match" = x""yes; then :
++if test "x$ac_cv_lib_nsl_yp_match" = xyes; then :
+   LIBNSL="-lnsl"
+ fi
+ 
+@@ -3962,7 +3996,7 @@ fi
+ 
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for res_query in -lresolv" >&5
+ $as_echo_n "checking for res_query in -lresolv... " >&6; }
+-if test "${ac_cv_lib_resolv_res_query+set}" = set; then :
++if ${ac_cv_lib_resolv_res_query+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   ac_check_lib_save_LIBS=$LIBS
+@@ -3996,7 +4030,7 @@ LIBS=$ac_check_lib_save_LIBS
+ fi
+ { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_resolv_res_query" >&5
+ $as_echo "$ac_cv_lib_resolv_res_query" >&6; }
+-if test "x$ac_cv_lib_resolv_res_query" = x""yes; then :
++if test "x$ac_cv_lib_resolv_res_query" = xyes; then :
+   LIBRESOLV="-lresolv"
+ fi
+ 
+@@ -4088,7 +4122,7 @@ if test -n "$CPP" && test -d "$CPP"; then
+   CPP=
+ fi
+ if test -z "$CPP"; then
+-  if test "${ac_cv_prog_CPP+set}" = set; then :
++  if ${ac_cv_prog_CPP+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+       # Double quotes because CPP needs to be expanded
+@@ -4118,7 +4152,7 @@ else
+   # Broken: fails on valid input.
+ continue
+ fi
+-rm -f conftest.err conftest.$ac_ext
++rm -f conftest.err conftest.i conftest.$ac_ext
+ 
+   # OK, works on sane cases.  Now check whether nonexistent headers
+   # can be detected and how.
+@@ -4134,11 +4168,11 @@ else
+ ac_preproc_ok=:
+ break
+ fi
+-rm -f conftest.err conftest.$ac_ext
++rm -f conftest.err conftest.i conftest.$ac_ext
+ 
+ done
+ # Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+-rm -f conftest.err conftest.$ac_ext
++rm -f conftest.i conftest.err conftest.$ac_ext
+ if $ac_preproc_ok; then :
+   break
+ fi
+@@ -4177,7 +4211,7 @@ else
+   # Broken: fails on valid input.
+ continue
+ fi
+-rm -f conftest.err conftest.$ac_ext
++rm -f conftest.err conftest.i conftest.$ac_ext
+ 
+   # OK, works on sane cases.  Now check whether nonexistent headers
+   # can be detected and how.
+@@ -4193,11 +4227,11 @@ else
+ ac_preproc_ok=:
+ break
+ fi
+-rm -f conftest.err conftest.$ac_ext
++rm -f conftest.err conftest.i conftest.$ac_ext
+ 
+ done
+ # Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+-rm -f conftest.err conftest.$ac_ext
++rm -f conftest.i conftest.err conftest.$ac_ext
+ if $ac_preproc_ok; then :
+ 
+ else
+@@ -4216,7 +4250,7 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
+ 
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e" >&5
+ $as_echo_n "checking for grep that handles long lines and -e... " >&6; }
+-if test "${ac_cv_path_GREP+set}" = set; then :
++if ${ac_cv_path_GREP+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   if test -z "$GREP"; then
+@@ -4279,7 +4313,7 @@ $as_echo "$ac_cv_path_GREP" >&6; }
+ 
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for egrep" >&5
+ $as_echo_n "checking for egrep... " >&6; }
+-if test "${ac_cv_path_EGREP+set}" = set; then :
++if ${ac_cv_path_EGREP+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   if echo a | $GREP -E '(a|b)' >/dev/null 2>&1
+@@ -4346,7 +4380,7 @@ $as_echo "$ac_cv_path_EGREP" >&6; }
+ 
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ANSI C header files" >&5
+ $as_echo_n "checking for ANSI C header files... " >&6; }
+-if test "${ac_cv_header_stdc+set}" = set; then :
++if ${ac_cv_header_stdc+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+@@ -4474,7 +4508,7 @@ done
+ 
+ 
+ ac_fn_c_check_header_mongrel "$LINENO" "rpcsvc/nis.h" "ac_cv_header_rpcsvc_nis_h" "$ac_includes_default"
+-if test "x$ac_cv_header_rpcsvc_nis_h" = x""yes; then :
++if test "x$ac_cv_header_rpcsvc_nis_h" = xyes; then :
+   HAVE_NISPLUS=1
+ fi
+ 
+@@ -4509,7 +4543,7 @@ if test -z "$HAVE_LDAP" -o "$HAVE_LDAP" != "0"; then
+ 	LDAP_FLAGS="$LDAP_FLAGS -DLDAP_DEPRECATED=1"
+ 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ldap_initialize in -lldap" >&5
+ $as_echo_n "checking for ldap_initialize in -lldap... " >&6; }
+-if test "${ac_cv_lib_ldap_ldap_initialize+set}" = set; then :
++if ${ac_cv_lib_ldap_ldap_initialize+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   ac_check_lib_save_LIBS=$LIBS
+@@ -4543,7 +4577,7 @@ LIBS=$ac_check_lib_save_LIBS
+ fi
+ { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_ldap_ldap_initialize" >&5
+ $as_echo "$ac_cv_lib_ldap_ldap_initialize" >&6; }
+-if test "x$ac_cv_lib_ldap_ldap_initialize" = x""yes; then :
++if test "x$ac_cv_lib_ldap_ldap_initialize" = xyes; then :
+   HAVE_LDAP=1 LIBLDAP="$LIBLDAP -lldap -llber -lresolv"
+ fi
+ 
+@@ -4677,7 +4711,7 @@ then
+ 	HAVE_SASL=0
+ 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for sasl_client_start in -lsasl2" >&5
+ $as_echo_n "checking for sasl_client_start in -lsasl2... " >&6; }
+-if test "${ac_cv_lib_sasl2_sasl_client_start+set}" = set; then :
++if ${ac_cv_lib_sasl2_sasl_client_start+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   ac_check_lib_save_LIBS=$LIBS
+@@ -4711,7 +4745,7 @@ LIBS=$ac_check_lib_save_LIBS
+ fi
+ { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_sasl2_sasl_client_start" >&5
+ $as_echo "$ac_cv_lib_sasl2_sasl_client_start" >&6; }
+-if test "x$ac_cv_lib_sasl2_sasl_client_start" = x""yes; then :
++if test "x$ac_cv_lib_sasl2_sasl_client_start" = xyes; then :
+   HAVE_SASL=1 LIBSASL="$LIBSASL -lsasl2"
+ fi
+ 
+@@ -4744,7 +4778,7 @@ if test -n "$ac_tool_prefix"; then
+ set dummy ${ac_tool_prefix}gcc; ac_word=$2
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+ $as_echo_n "checking for $ac_word... " >&6; }
+-if test "${ac_cv_prog_CC+set}" = set; then :
++if ${ac_cv_prog_CC+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   if test -n "$CC"; then
+@@ -4784,7 +4818,7 @@ if test -z "$ac_cv_prog_CC"; then
+ set dummy gcc; ac_word=$2
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+ $as_echo_n "checking for $ac_word... " >&6; }
+-if test "${ac_cv_prog_ac_ct_CC+set}" = set; then :
++if ${ac_cv_prog_ac_ct_CC+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   if test -n "$ac_ct_CC"; then
+@@ -4837,7 +4871,7 @@ if test -z "$CC"; then
+ set dummy ${ac_tool_prefix}cc; ac_word=$2
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+ $as_echo_n "checking for $ac_word... " >&6; }
+-if test "${ac_cv_prog_CC+set}" = set; then :
++if ${ac_cv_prog_CC+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   if test -n "$CC"; then
+@@ -4877,7 +4911,7 @@ if test -z "$CC"; then
+ set dummy cc; ac_word=$2
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+ $as_echo_n "checking for $ac_word... " >&6; }
+-if test "${ac_cv_prog_CC+set}" = set; then :
++if ${ac_cv_prog_CC+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   if test -n "$CC"; then
+@@ -4936,7 +4970,7 @@ if test -z "$CC"; then
+ set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+ $as_echo_n "checking for $ac_word... " >&6; }
+-if test "${ac_cv_prog_CC+set}" = set; then :
++if ${ac_cv_prog_CC+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   if test -n "$CC"; then
+@@ -4980,7 +5014,7 @@ do
+ set dummy $ac_prog; ac_word=$2
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+ $as_echo_n "checking for $ac_word... " >&6; }
+-if test "${ac_cv_prog_ac_ct_CC+set}" = set; then :
++if ${ac_cv_prog_ac_ct_CC+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   if test -n "$ac_ct_CC"; then
+@@ -5064,7 +5098,7 @@ done
+ 
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C compiler" >&5
+ $as_echo_n "checking whether we are using the GNU C compiler... " >&6; }
+-if test "${ac_cv_c_compiler_gnu+set}" = set; then :
++if ${ac_cv_c_compiler_gnu+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+@@ -5101,7 +5135,7 @@ ac_test_CFLAGS=${CFLAGS+set}
+ ac_save_CFLAGS=$CFLAGS
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
+ $as_echo_n "checking whether $CC accepts -g... " >&6; }
+-if test "${ac_cv_prog_cc_g+set}" = set; then :
++if ${ac_cv_prog_cc_g+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   ac_save_c_werror_flag=$ac_c_werror_flag
+@@ -5179,7 +5213,7 @@ else
+ fi
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $CC option to accept ISO C89" >&5
+ $as_echo_n "checking for $CC option to accept ISO C89... " >&6; }
+-if test "${ac_cv_prog_cc_c89+set}" = set; then :
++if ${ac_cv_prog_cc_c89+:} false; then :
+   $as_echo_n "(cached) " >&6
+ else
+   ac_cv_prog_cc_c89=no
+@@ -5432,7 +5466,7 @@ LTLIBOBJS=$ac_ltlibobjs
+ 
+ 
+ 
+-: ${CONFIG_STATUS=./config.status}
++: "${CONFIG_STATUS=./config.status}"
+ ac_write_fail=0
+ ac_clean_files_save=$ac_clean_files
+ ac_clean_files="$ac_clean_files $CONFIG_STATUS"
+@@ -5533,6 +5567,7 @@ fi
+ IFS=" ""	$as_nl"
+ 
+ # Find who we are.  Look in the path if we contain no directory separator.
++as_myself=
+ case $0 in #((
+   *[\\/]* ) as_myself=$0 ;;
+   *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+@@ -5840,7 +5875,7 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+ # values after options handling.
+ ac_log="
+ This file was extended by $as_me, which was
+-generated by GNU Autoconf 2.66.  Invocation command line was
++generated by GNU Autoconf 2.68.  Invocation command line was
+ 
+   CONFIG_FILES    = $CONFIG_FILES
+   CONFIG_HEADERS  = $CONFIG_HEADERS
+@@ -5902,7 +5937,7 @@ cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+ ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
+ ac_cs_version="\\
+ config.status
+-configured by $0, generated by GNU Autoconf 2.66,
++configured by $0, generated by GNU Autoconf 2.68,
+   with options \\"\$ac_cs_config\\"
+ 
+ Copyright (C) 2010 Free Software Foundation, Inc.
+@@ -5920,11 +5955,16 @@ ac_need_defaults=:
+ while test $# != 0
+ do
+   case $1 in
+-  --*=*)
++  --*=?*)
+     ac_option=`expr "X$1" : 'X\([^=]*\)='`
+     ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
+     ac_shift=:
+     ;;
++  --*=)
++    ac_option=`expr "X$1" : 'X\([^=]*\)='`
++    ac_optarg=
++    ac_shift=:
++    ;;
+   *)
+     ac_option=$1
+     ac_optarg=$2
+@@ -5946,6 +5986,7 @@ do
+     $ac_shift
+     case $ac_optarg in
+     *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
++    '') as_fn_error $? "missing file argument" ;;
+     esac
+     as_fn_append CONFIG_FILES " '$ac_optarg'"
+     ac_need_defaults=false;;
+@@ -6041,9 +6082,10 @@ fi
+ # after its creation but before its name has been assigned to `$tmp'.
+ $debug ||
+ {
+-  tmp=
++  tmp= ac_tmp=
+   trap 'exit_status=$?
+-  { test -z "$tmp" || test ! -d "$tmp" || rm -fr "$tmp"; } && exit $exit_status
++  : "${ac_tmp:=$tmp}"
++  { test ! -d "$ac_tmp" || rm -fr "$ac_tmp"; } && exit $exit_status
+ ' 0
+   trap 'as_fn_exit 1' 1 2 13 15
+ }
+@@ -6051,12 +6093,13 @@ $debug ||
+ 
+ {
+   tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
+-  test -n "$tmp" && test -d "$tmp"
++  test -d "$tmp"
+ }  ||
+ {
+   tmp=./conf$$-$RANDOM
+   (umask 077 && mkdir "$tmp")
+ } || as_fn_error $? "cannot create a temporary directory in ." "$LINENO" 5
++ac_tmp=$tmp
+ 
+ # Set up the scripts for CONFIG_FILES section.
+ # No need to generate them if there are no CONFIG_FILES.
+@@ -6078,7 +6121,7 @@ else
+   ac_cs_awk_cr=$ac_cr
+ fi
+ 
+-echo 'BEGIN {' >"$tmp/subs1.awk" &&
++echo 'BEGIN {' >"$ac_tmp/subs1.awk" &&
+ _ACEOF
+ 
+ 
+@@ -6106,7 +6149,7 @@ done
+ rm -f conf$$subs.sh
+ 
+ cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+-cat >>"\$tmp/subs1.awk" <<\\_ACAWK &&
++cat >>"\$ac_tmp/subs1.awk" <<\\_ACAWK &&
+ _ACEOF
+ sed -n '
+ h
+@@ -6154,7 +6197,7 @@ t delim
+ rm -f conf$$subs.awk
+ cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+ _ACAWK
+-cat >>"\$tmp/subs1.awk" <<_ACAWK &&
++cat >>"\$ac_tmp/subs1.awk" <<_ACAWK &&
+   for (key in S) S_is_set[key] = 1
+   FS = ""
+ 
+@@ -6186,7 +6229,7 @@ if sed "s/$ac_cr//" < /dev/null > /dev/null 2>&1; then
+   sed "s/$ac_cr\$//; s/$ac_cr/$ac_cs_awk_cr/g"
+ else
+   cat
+-fi < "$tmp/subs1.awk" > "$tmp/subs.awk" \
++fi < "$ac_tmp/subs1.awk" > "$ac_tmp/subs.awk" \
+   || as_fn_error $? "could not setup config files machinery" "$LINENO" 5
+ _ACEOF
+ 
+@@ -6220,7 +6263,7 @@ fi # test -n "$CONFIG_FILES"
+ # No need to generate them if there are no CONFIG_HEADERS.
+ # This happens for instance with `./config.status Makefile'.
+ if test -n "$CONFIG_HEADERS"; then
+-cat >"$tmp/defines.awk" <<\_ACAWK ||
++cat >"$ac_tmp/defines.awk" <<\_ACAWK ||
+ BEGIN {
+ _ACEOF
+ 
+@@ -6232,8 +6275,8 @@ _ACEOF
+ # handling of long lines.
+ ac_delim='%!_!# '
+ for ac_last_try in false false :; do
+-  ac_t=`sed -n "/$ac_delim/p" confdefs.h`
+-  if test -z "$ac_t"; then
++  ac_tt=`sed -n "/$ac_delim/p" confdefs.h`
++  if test -z "$ac_tt"; then
+     break
+   elif $ac_last_try; then
+     as_fn_error $? "could not make $CONFIG_HEADERS" "$LINENO" 5
+@@ -6353,7 +6396,7 @@ do
+     for ac_f
+     do
+       case $ac_f in
+-      -) ac_f="$tmp/stdin";;
++      -) ac_f="$ac_tmp/stdin";;
+       *) # Look for the file first in the build tree, then in the source tree
+ 	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
+ 	 # because $ac_f cannot contain `:'.
+@@ -6388,7 +6431,7 @@ $as_echo "$as_me: creating $ac_file" >&6;}
+     esac
+ 
+     case $ac_tag in
+-    *:-:* | *:-) cat >"$tmp/stdin" \
++    *:-:* | *:-) cat >"$ac_tmp/stdin" \
+       || as_fn_error $? "could not create $ac_file" "$LINENO" 5 ;;
+     esac
+     ;;
+@@ -6514,21 +6557,22 @@ s&@abs_builddir@&$ac_abs_builddir&;t t
+ s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
+ $ac_datarootdir_hack
+ "
+-eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$tmp/subs.awk" >$tmp/out \
+-  || as_fn_error $? "could not create $ac_file" "$LINENO" 5
++eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$ac_tmp/subs.awk" \
++  >$ac_tmp/out || as_fn_error $? "could not create $ac_file" "$LINENO" 5
+ 
+ test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
+-  { ac_out=`sed -n '/\${datarootdir}/p' "$tmp/out"`; test -n "$ac_out"; } &&
+-  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' "$tmp/out"`; test -z "$ac_out"; } &&
++  { ac_out=`sed -n '/\${datarootdir}/p' "$ac_tmp/out"`; test -n "$ac_out"; } &&
++  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' \
++      "$ac_tmp/out"`; test -z "$ac_out"; } &&
+   { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+ which seems to be undefined.  Please make sure it is defined" >&5
+ $as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+ which seems to be undefined.  Please make sure it is defined" >&2;}
+ 
+-  rm -f "$tmp/stdin"
++  rm -f "$ac_tmp/stdin"
+   case $ac_file in
+-  -) cat "$tmp/out" && rm -f "$tmp/out";;
+-  *) rm -f "$ac_file" && mv "$tmp/out" "$ac_file";;
++  -) cat "$ac_tmp/out" && rm -f "$ac_tmp/out";;
++  *) rm -f "$ac_file" && mv "$ac_tmp/out" "$ac_file";;
+   esac \
+   || as_fn_error $? "could not create $ac_file" "$LINENO" 5
+  ;;
+@@ -6539,20 +6583,20 @@ which seems to be undefined.  Please make sure it is defined" >&2;}
+   if test x"$ac_file" != x-; then
+     {
+       $as_echo "/* $configure_input  */" \
+-      && eval '$AWK -f "$tmp/defines.awk"' "$ac_file_inputs"
+-    } >"$tmp/config.h" \
++      && eval '$AWK -f "$ac_tmp/defines.awk"' "$ac_file_inputs"
++    } >"$ac_tmp/config.h" \
+       || as_fn_error $? "could not create $ac_file" "$LINENO" 5
+-    if diff "$ac_file" "$tmp/config.h" >/dev/null 2>&1; then
++    if diff "$ac_file" "$ac_tmp/config.h" >/dev/null 2>&1; then
+       { $as_echo "$as_me:${as_lineno-$LINENO}: $ac_file is unchanged" >&5
+ $as_echo "$as_me: $ac_file is unchanged" >&6;}
+     else
+       rm -f "$ac_file"
+-      mv "$tmp/config.h" "$ac_file" \
++      mv "$ac_tmp/config.h" "$ac_file" \
+ 	|| as_fn_error $? "could not create $ac_file" "$LINENO" 5
+     fi
+   else
+     $as_echo "/* $configure_input  */" \
+-      && eval '$AWK -f "$tmp/defines.awk"' "$ac_file_inputs" \
++      && eval '$AWK -f "$ac_tmp/defines.awk"' "$ac_file_inputs" \
+       || as_fn_error $? "could not create -" "$LINENO" 5
+   fi
+  ;;
+diff --git a/configure.in b/configure.in
+index 05ee67f..c017829 100644
+--- a/configure.in
++++ b/configure.in
+@@ -148,6 +148,10 @@ AF_CHECK_PROG(YACC, bison, , $searchpath)
+ AF_CHECK_PROG(RANLIB, ranlib, , $searchpath)
+ AF_CHECK_PROG(RPCGEN, rpcgen, , $searchpath)
+ 
++AF_CHECK_SSS_LIB(SSS_AUTOFS, libsss_autofs.so)
++AC_SUBST(HAVE_SSS_AUTOFS)
++AC_SUBST(sssldir)
++
+ #
+ # Newer mounts have the -s (sloppy) option to ignore unknown options,
+ # good for portability
+diff --git a/modules/Makefile b/modules/Makefile
+index 6090127..939da7c 100644
+--- a/modules/Makefile
++++ b/modules/Makefile
+@@ -47,6 +47,12 @@ ifeq ($(LDAP), 1)
+   endif
+ endif
+ 
++ifeq ($(SSSD), 1)
++  CFLAGS += -DSSS_LIB_DIR=\"$(ssslibdir)\"
++  SRCS += lookup_sss.c
++  MODS += lookup_sss.so
++endif
++
+ CFLAGS += -I../include -I../lib -fPIC -D_GNU_SOURCE
+ CFLAGS += -DAUTOFS_LIB_DIR=\"$(autofslibdir)\"
+ CFLAGS += -DAUTOFS_MAP_DIR=\"$(autofsmapdir)\"
+diff --git a/modules/lookup_sss.c b/modules/lookup_sss.c
+new file mode 100644
+index 0000000..02a4be9
+--- /dev/null
++++ b/modules/lookup_sss.c
+@@ -0,0 +1,678 @@
++/* ----------------------------------------------------------------------- *
++ *
++ *  lookup_sss.c - module for Linux automount to query sss service
++ *
++ *   Copyright 2012 Ian Kent <raven@themaw.net>
++ *   Copyright 2012 Red Hat, Inc.
++ *
++ *   This program is free software; you can redistribute it and/or modify
++ *   it under the terms of the GNU General Public License as published by
++ *   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge MA 02139,
++ *   USA; either version 2 of the License, or (at your option) any later
++ *   version; incorporated herein by reference.
++ *
++ * ----------------------------------------------------------------------- */
++
++#include <stdio.h>
++#include <malloc.h>
++#include <stdlib.h>
++#include <ctype.h>
++#include <dlfcn.h>
++#include <errno.h>
++#include <string.h>
++#include <sys/param.h>
++#include <sys/types.h>
++#include <sys/stat.h>
++
++#define MODULE_LOOKUP
++#include "automount.h"
++#include "nsswitch.h"
++
++#define MAPFMT_DEFAULT "sun"
++
++#define MODPREFIX "lookup(sss): "
++
++#define SSS_SO_NAME "libsss_autofs"
++
++int _sss_setautomntent(const char *, void **);
++int _sss_getautomntent_r(char **, char **, void *);
++int _sss_getautomntbyname_r(char *, char **, void *);
++int _sss_endautomntent(void **);
++
++typedef int (*setautomntent_t) (const char *, void **);
++typedef int (*getautomntent_t) (char **, char **, void *);
++typedef int (*getautomntbyname_t) (char *, char **, void *);
++typedef int (*endautomntent_t) (void **);
++
++struct lookup_context {
++	const char *mapname;
++    	void *dlhandle;
++	setautomntent_t setautomntent;
++	getautomntent_t getautomntent_r;
++	getautomntbyname_t getautomntbyname_r;
++	endautomntent_t endautomntent;
++	struct parse_mod *parse;
++};
++
++int lookup_version = AUTOFS_LOOKUP_VERSION;	/* Required by protocol */
++
++int lookup_init(const char *mapfmt, int argc, const char *const *argv, void **context)
++{
++	struct lookup_context *ctxt;
++	char buf[MAX_ERR_BUF];
++	char dlbuf[PATH_MAX];
++	char *estr;
++	void *dh;
++	size_t size;
++
++	*context = NULL;
++
++	ctxt = malloc(sizeof(struct lookup_context));
++	if (!ctxt) {
++		estr = strerror_r(errno, buf, MAX_ERR_BUF);
++		logerr(MODPREFIX "malloc: %s", estr);
++		return 1;
++	}
++
++	if (argc < 1) {
++		free(ctxt);
++		logerr(MODPREFIX "No map name");
++		return 1;
++	}
++	ctxt->mapname = argv[0];
++
++	if (!mapfmt)
++		mapfmt = MAPFMT_DEFAULT;
++
++	size = snprintf(dlbuf, sizeof(dlbuf),
++			"%s/%s.so", SSS_LIB_DIR, SSS_SO_NAME);
++	if (size >= sizeof(dlbuf)) {
++		free(ctxt);
++		logmsg(MODPREFIX "sss library path too long");
++		return 1;
++	}
++
++	dh = dlopen(dlbuf, RTLD_LAZY);
++	if (!dh) {
++		estr = strerror_r(errno, buf, MAX_ERR_BUF);
++		logerr(MODPREFIX "dlopen: %s", estr);
++		free(ctxt);
++		return 1;
++	}
++	ctxt->dlhandle = dh;
++
++	ctxt->setautomntent = (setautomntent_t) dlsym(dh, "_sss_setautomntent");
++	if (!ctxt->setautomntent)
++		goto lib_names_fail;
++
++	ctxt->getautomntent_r = (getautomntent_t) dlsym(dh, "_sss_getautomntent_r");
++	if (!ctxt->getautomntent_r)
++		goto lib_names_fail;
++
++	ctxt->getautomntbyname_r = (getautomntbyname_t) dlsym(dh, "_sss_getautomntbyname_r");
++	if (!ctxt->getautomntbyname_r)
++		goto lib_names_fail;
++
++	ctxt->endautomntent = (endautomntent_t) dlsym(dh, "_sss_endautomntent");
++	if (!ctxt->setautomntent)
++		goto lib_names_fail;
++
++	ctxt->parse = open_parse(mapfmt, MODPREFIX, argc - 1, argv + 1);
++	if (!ctxt->parse) {
++		logmsg(MODPREFIX "failed to open parse context");
++		dlclose(dh);
++		free(ctxt);
++		return 1;
++	}
++	*context = ctxt;
++
++	return 0;
++
++lib_names_fail:
++	if ((estr = dlerror()) == NULL)
++		logmsg(MODPREFIX "failed to locate sss library entry points");
++	else
++		logerr(MODPREFIX "dlsym: %s", estr);
++	dlclose(dh);
++	free(ctxt);
++	return 1;
++}
++
++static int setautomntent(unsigned int logopt,
++			 struct lookup_context *ctxt, const char *mapname,
++			 void **sss_ctxt)
++{
++	int ret = ctxt->setautomntent(mapname, sss_ctxt);
++	if (ret) {
++		char buf[MAX_ERR_BUF];
++		char *estr = strerror_r(ret, buf, MAX_ERR_BUF);
++		error(logopt, MODPREFIX "setautomntent: %s", estr);
++		if (*sss_ctxt)
++			free(*sss_ctxt);
++		return 0;
++	}
++	return 1;
++}
++
++static int endautomntent(unsigned int logopt,
++			 struct lookup_context *ctxt, void **sss_ctxt)
++{
++	int ret = ctxt->endautomntent(sss_ctxt);
++	if (ret) {
++		char buf[MAX_ERR_BUF];
++		char *estr = strerror_r(ret, buf, MAX_ERR_BUF);
++		error(logopt, MODPREFIX "endautomntent: %s", estr);
++		return 0;
++	}
++	return 1;
++}
++
++int lookup_read_master(struct master *master, time_t age, void *context)
++{
++	struct lookup_context *ctxt = (struct lookup_context *) context;
++	unsigned int timeout = master->default_timeout;
++	unsigned int logging = master->default_logging;
++	unsigned int logopt = master->logopt;
++	void *sss_ctxt = NULL;
++	char buf[MAX_ERR_BUF];
++	char *buffer;
++	size_t buffer_len;
++	char *key;
++	char *value = NULL;
++	int count, ret;
++
++	if (!setautomntent(logopt, ctxt, ctxt->mapname, &sss_ctxt))
++		return NSS_STATUS_UNAVAIL;
++
++	count = 0;
++	while (1) {
++	        key = NULL;
++	        value = NULL;
++		ret = ctxt->getautomntent_r(&key, &value, sss_ctxt);
++		if (ret && ret != ENOENT) {
++			char *estr = strerror_r(ret, buf, MAX_ERR_BUF);
++			error(logopt, MODPREFIX "getautomntent_r: %s", estr);
++			endautomntent(logopt, ctxt, &sss_ctxt);
++			if (key)
++				free(key);
++			if (value)
++				free(value);
++			return NSS_STATUS_UNAVAIL;
++		}
++		if (ret == ENOENT) {
++			if (!count) {
++				char *estr = strerror_r(ret, buf, MAX_ERR_BUF);
++				error(logopt, MODPREFIX "getautomntent_r: %s", estr);
++				endautomntent(logopt, ctxt, &sss_ctxt);
++				if (key)
++					free(key);
++				if (value)
++					free(value);
++				return NSS_STATUS_NOTFOUND;
++			}
++			break;
++		}
++		count++;
++
++		buffer_len = strlen(key) + 1 + strlen(value) + 2;
++		buffer = malloc(buffer_len);
++		if (!buffer) {
++			char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
++			error(logopt, MODPREFIX "malloc: %s", estr);
++			endautomntent(logopt, ctxt, &sss_ctxt);
++			free(key);
++			free(value);
++			return NSS_STATUS_UNAVAIL;
++		}
++
++		/*
++		 * TODO: implement sun % hack for key translation for
++		 * mixed case keys in schema that are single case only.
++		 */
++
++		strcpy(buffer, key);
++		strcat(buffer, " ");
++		strcat(buffer, value);
++
++		/*
++		 * TODO: handle cancelation. This almost certainly isn't
++		 * handled properly by other lookup modules either so it
++		 * should be done when cancelation is reviewed for the
++		 * other modules. Ditto for the other lookup module entry
++		 * points.
++		 */
++		master_parse_entry(buffer, timeout, logging, age);
++
++		free(buffer);
++		free(key);
++		free(value);
++	}
++
++	endautomntent(logopt, ctxt, &sss_ctxt);
++
++	return NSS_STATUS_SUCCESS;
++}
++
++int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
++{
++	struct lookup_context *ctxt = (struct lookup_context *) context;
++	struct map_source *source;
++	struct mapent_cache *mc;
++	void *sss_ctxt = NULL;
++	char buf[MAX_ERR_BUF];
++	char *key;
++	char *value = NULL;
++	char *s_key;
++	int count, ret;
++
++	source = ap->entry->current;
++	ap->entry->current = NULL;
++	master_source_current_signal(ap->entry);
++
++	mc = source->mc;
++
++	/*
++	 * If we don't need to create directories then there's no use
++	 * reading the map. We always need to read the whole map for
++	 * direct mounts in order to mount the triggers.
++	 */
++	if (!(ap->flags & MOUNT_FLAG_GHOST) && ap->type != LKP_DIRECT)
++		return NSS_STATUS_SUCCESS;
++
++	if (!setautomntent(ap->logopt, ctxt, ctxt->mapname, &sss_ctxt))
++		return NSS_STATUS_UNAVAIL;
++
++	count = 0;
++	while (1) {
++	        key = NULL;
++	        value = NULL;
++		ret = ctxt->getautomntent_r(&key, &value, sss_ctxt);
++		if (ret && ret != ENOENT) {
++			char *estr = strerror_r(ret, buf, MAX_ERR_BUF);
++			error(ap->logopt,
++			      MODPREFIX "getautomntent_r: %s", estr);
++			endautomntent(ap->logopt, ctxt, &sss_ctxt);
++			if (key)
++				free(key);
++			if (value)
++				free(value);
++			return NSS_STATUS_UNAVAIL;
++		}
++		if (ret == ENOENT) {
++			if (!count) {
++				char *estr = strerror_r(ret, buf, MAX_ERR_BUF);
++				error(ap->logopt,
++				      MODPREFIX "getautomntent_r: %s", estr);
++				endautomntent(ap->logopt, ctxt, &sss_ctxt);
++				if (key)
++					free(key);
++				if (value)
++					free(value);
++				return NSS_STATUS_NOTFOUND;
++			}
++			break;
++		}
++
++		/*
++		 * Ignore keys beginning with '+' as plus map
++		 * inclusion is only valid in file maps.
++		 */
++		if (*key == '+') {
++			warn(ap->logopt,
++			     MODPREFIX "ignoring '+' map entry - not in file map");
++			free(key);
++			free(value);
++			continue;
++		}
++
++		/*
++		 * TODO: implement sun % hack for key translation for
++		 * mixed case keys in schema that are single case only.
++		 */
++
++		s_key = sanitize_path(key, strlen(key), ap->type, ap->logopt);
++		if (!s_key) {
++			error(ap->logopt, MODPREFIX "invalid path %s", key);
++			endautomntent(ap->logopt, ctxt, &sss_ctxt);
++			free(key);
++			free(value);
++			return NSS_STATUS_NOTFOUND;
++		}
++
++		count++;
++
++		cache_writelock(mc);
++		cache_update(mc, source, s_key, value, age);
++		cache_unlock(mc);
++
++		free(s_key);
++		free(key);
++		free(value);
++	}
++
++	endautomntent(ap->logopt, ctxt, &sss_ctxt);
++
++	return NSS_STATUS_SUCCESS;
++}
++
++static int lookup_one(struct autofs_point *ap,
++		char *qKey, int qKey_len, struct lookup_context *ctxt)
++{
++	struct map_source *source;
++	struct mapent_cache *mc;
++	struct mapent *we;
++	void *sss_ctxt = NULL;
++	time_t age = time(NULL);
++	char buf[MAX_ERR_BUF];
++	char *value = NULL;
++	char *s_key;
++	int ret;
++
++	source = ap->entry->current;
++	ap->entry->current = NULL;
++	master_source_current_signal(ap->entry);
++
++	mc = source->mc;
++
++	if (!setautomntent(ap->logopt, ctxt, ctxt->mapname, &sss_ctxt))
++		return NSS_STATUS_UNAVAIL;
++
++	ret = ctxt->getautomntbyname_r(qKey, &value, sss_ctxt);
++	if (ret && ret != ENOENT) {
++		char *estr = strerror_r(ret, buf, MAX_ERR_BUF);
++		error(ap->logopt,
++		      MODPREFIX "getautomntbyname_r: %s", estr);
++		endautomntent(ap->logopt, ctxt, &sss_ctxt);
++		if (value)
++			free(value);
++		return NSS_STATUS_UNAVAIL;
++	}
++	if (ret != ENOENT) {
++		/*
++		 * TODO: implement sun % hack for key translation for
++		 * mixed case keys in schema that are single case only.
++		 */
++		s_key = sanitize_path(qKey, qKey_len, ap->type, ap->logopt);
++		if (!s_key) {
++			free(value);
++			value = NULL;
++			goto wild;
++		}
++		cache_writelock(mc);
++		ret = cache_update(mc, source, s_key, value, age);
++		cache_unlock(mc);
++		endautomntent(ap->logopt, ctxt, &sss_ctxt);
++		free(s_key);
++		free(value);
++		return NSS_STATUS_SUCCESS;
++	}
++
++wild:
++	ret = ctxt->getautomntbyname_r("/", &value, sss_ctxt);
++	if (ret && ret != ENOENT) {
++		char *estr = strerror_r(ret, buf, MAX_ERR_BUF);
++		error(ap->logopt,
++		      MODPREFIX "getautomntbyname_r: %s", estr);
++		endautomntent(ap->logopt, ctxt, &sss_ctxt);
++		if (value)
++			free(value);
++		return NSS_STATUS_UNAVAIL;
++	}
++	if (ret == ENOENT) {
++		ret = ctxt->getautomntbyname_r("*", &value, sss_ctxt);
++		if (ret && ret != ENOENT) {
++			char *estr = strerror_r(ret, buf, MAX_ERR_BUF);
++			error(ap->logopt,
++			      MODPREFIX "getautomntbyname_r: %s", estr);
++			endautomntent(ap->logopt, ctxt, &sss_ctxt);
++			if (value)
++				free(value);
++			return NSS_STATUS_UNAVAIL;
++		}
++	}
++
++	if (ret == ENOENT) {
++		/* Failed to find wild entry, update cache if needed */
++		cache_writelock(mc);
++		we = cache_lookup_distinct(mc, "*");
++		if (we) {
++			/* Wildcard entry existed and is now gone */
++			if (we->source == source) {
++				cache_delete(mc, "*");
++				source->stale = 1;
++			}
++		}
++
++		/* Not found in the map but found in the cache */
++		struct mapent *exists = cache_lookup_distinct(mc, qKey);
++		if (exists && exists->source == source) {
++			if (exists->mapent) {
++				free(exists->mapent);
++				exists->mapent = NULL;
++				source->stale = 1;
++				exists->status = 0;
++			}
++		}
++		cache_unlock(mc);
++		endautomntent(ap->logopt, ctxt, &sss_ctxt);
++		return NSS_STATUS_NOTFOUND;
++	}
++
++	cache_writelock(mc);
++	/* Wildcard not in map but now is */
++	we = cache_lookup_distinct(mc, "*");
++	if (!we)
++		source->stale = 1;
++	ret = cache_update(mc, source, "*", value, age);
++	cache_unlock(mc);
++
++	endautomntent(ap->logopt, ctxt, &sss_ctxt);
++        free(value);
++
++	return NSS_STATUS_SUCCESS;
++}
++
++static int check_map_indirect(struct autofs_point *ap,
++			      char *key, int key_len,
++			      struct lookup_context *ctxt)
++{
++	struct map_source *source;
++	struct mapent_cache *mc;
++	struct mapent *me;
++	time_t now = time(NULL);
++	time_t t_last_read;
++	int ret, cur_state;
++
++	source = ap->entry->current;
++	ap->entry->current = NULL;
++	master_source_current_signal(ap->entry);
++
++	mc = source->mc;
++
++	master_source_current_wait(ap->entry);
++	ap->entry->current = source;
++
++	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cur_state);
++	ret = lookup_one(ap, key, key_len, ctxt);
++	if (ret == NSS_STATUS_NOTFOUND) {
++		pthread_setcancelstate(cur_state, NULL);
++		return ret;
++	} else if (ret == NSS_STATUS_UNAVAIL) {
++		/*
++		 * If the server is down and the entry exists in the cache
++		 * and belongs to this map return success and use the entry.
++		 */
++		struct mapent *exists = cache_lookup(mc, key);
++		if (exists && exists->source == source) {
++			pthread_setcancelstate(cur_state, NULL);
++			return NSS_STATUS_SUCCESS;
++		}
++		pthread_setcancelstate(cur_state, NULL);
++
++		warn(ap->logopt,
++		     MODPREFIX "lookup for %s failed: connection failed", key);
++
++		return ret;
++	}
++	pthread_setcancelstate(cur_state, NULL);
++
++	/*
++	 * Check for map change and update as needed for
++	 * following cache lookup.
++	 */
++	cache_readlock(mc);
++	t_last_read = ap->exp_runfreq + 1;
++	me = cache_lookup_first(mc);
++	while (me) {
++		if (me->source == source) {
++			t_last_read = now - me->age;
++			break;
++		}
++		me = cache_lookup_next(mc, me);
++	}
++	cache_unlock(mc);
++
++	if (t_last_read > ap->exp_runfreq && ret & CHE_UPDATED)
++		source->stale = 1;
++
++	cache_readlock(mc);
++	me = cache_lookup_distinct(mc, "*");
++	if (ret == CHE_MISSING && (!me || me->source != source)) {
++		cache_unlock(mc);
++		return NSS_STATUS_NOTFOUND;
++	}
++	cache_unlock(mc);
++
++	return NSS_STATUS_SUCCESS;
++}
++
++int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *context)
++{
++	struct lookup_context *ctxt = (struct lookup_context *) context;
++	struct map_source *source;
++	struct mapent_cache *mc;
++	struct mapent *me;
++	char key[KEY_MAX_LEN + 1];
++	int key_len;
++	char *mapent = NULL;
++	char mapent_buf[MAPENT_MAX_LEN + 1];
++	int ret;
++
++	source = ap->entry->current;
++	ap->entry->current = NULL;
++	master_source_current_signal(ap->entry);
++
++	mc = source->mc;
++
++	debug(ap->logopt, MODPREFIX "looking up %s", name);
++
++	key_len = snprintf(key, KEY_MAX_LEN + 1, "%s", name);
++	if (key_len > KEY_MAX_LEN)
++		return NSS_STATUS_NOTFOUND;
++
++	/* Check if we recorded a mount fail for this key anywhere */
++	me = lookup_source_mapent(ap, key, LKP_DISTINCT);
++	if (me) {
++		if (me->status >= time(NULL)) {
++			cache_unlock(me->mc);
++			return NSS_STATUS_NOTFOUND;
++		} else {
++			struct mapent_cache *smc = me->mc;
++			struct mapent *sme;
++
++			if (me->mapent)
++				cache_unlock(smc);
++			else {
++				cache_unlock(smc);
++				cache_writelock(smc);
++				sme = cache_lookup_distinct(smc, key);
++				/* Negative timeout expired for non-existent entry. */
++				if (sme && !sme->mapent)
++					cache_delete(smc, key);
++				cache_unlock(smc);
++			}
++		}
++	}
++
++        /*
++	 * We can't check the direct mount map as if it's not in
++	 * the map cache already we never get a mount lookup, so
++	 * we never know about it.
++	 */
++	if (ap->type == LKP_INDIRECT && *key != '/') {
++		int status;
++		char *lkp_key;
++
++		cache_readlock(mc);
++		me = cache_lookup_distinct(mc, key);
++		if (me && me->multi)
++			lkp_key = strdup(me->multi->key);
++		else
++			lkp_key = strdup(key);
++		cache_unlock(mc);
++
++		if (!lkp_key)
++			return NSS_STATUS_UNKNOWN;
++
++		master_source_current_wait(ap->entry);
++		ap->entry->current = source;
++
++		status = check_map_indirect(ap, lkp_key, strlen(lkp_key), ctxt);
++		free(lkp_key);
++		if (status)
++			return status;
++	}
++
++	cache_readlock(mc);
++	me = cache_lookup(mc, key);
++	/* Stale mapent => check for entry in alternate source or wildcard */
++	if (me && !me->mapent) {
++		while ((me = cache_lookup_key_next(me)))
++			if (me->source == source)
++				break;
++		if (!me)
++			me = cache_lookup_distinct(mc, "*");
++	}
++	if (me && me->mapent && (me->source == source || *me->key == '/')) {
++		strcpy(mapent_buf, me->mapent);
++		mapent = mapent_buf;
++	}
++	cache_unlock(mc);
++
++	if (!mapent)
++		return NSS_STATUS_TRYAGAIN;
++
++	master_source_current_wait(ap->entry);
++	ap->entry->current = source;
++
++	debug(ap->logopt, MODPREFIX "%s -> %s", key, mapent);
++	ret = ctxt->parse->parse_mount(ap, key, key_len,
++				       mapent, ctxt->parse->context);
++	if (ret) {
++		time_t now = time(NULL);
++		int rv = CHE_OK;
++
++		/* Record the the mount fail in the cache */
++		cache_writelock(mc);
++		me = cache_lookup_distinct(mc, key);
++		if (!me)
++			rv = cache_update(mc, source, key, NULL, now);
++		if (rv != CHE_FAIL) {
++			me = cache_lookup_distinct(mc, key);
++			me->status = now + ap->negative_timeout;
++		}
++		cache_unlock(mc);
++		return NSS_STATUS_TRYAGAIN;
++	}
++
++	return NSS_STATUS_SUCCESS;
++}
++
++int lookup_done(void *context)
++{
++	struct lookup_context *ctxt = (struct lookup_context *) context;
++	int rv = close_parse(ctxt->parse);
++	dlclose(ctxt->dlhandle);
++	free(ctxt);
++	return rv;
++}
Index: backfire/feeds/packages/utils/autofs/patches/126-autofs-5.0.6-teach-automount-about-sss-source.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/126-autofs-5.0.6-teach-automount-about-sss-source.patch
@@ -0,0 +1,93 @@
+autofs-5.0.6 - teach automount about sss source
+
+From: Ian Kent <raven@themaw.net>
+
+Add parser and conditional checks to automount to handle sss source.
+Note, the parsing probably needs more work, both for master map entries
+and map entries, to attempt to narrow invalid map names passed down to
+lower level modules. For now we have to just handle these failures in
+the lookup module.
+---
+
+ CHANGELOG           |    1 +
+ daemon/lookup.c     |    1 +
+ lib/master_tok.l    |    2 +-
+ lib/nss_parse.y     |    6 ++++--
+ modules/parse_sun.c |    2 +-
+ 5 files changed, 8 insertions(+), 4 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index ba6f90c..e276396 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -24,6 +24,7 @@
+ - fix improve mount location error reporting.
+ - fix fix wait for master source mutex.
+ - add sss lookup module.
++- teach automount about sss source.
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/daemon/lookup.c b/daemon/lookup.c
+index 098588c..de7c817 100644
+--- a/daemon/lookup.c
++++ b/daemon/lookup.c
+@@ -177,6 +177,7 @@ int lookup_nss_read_master(struct master *master, time_t age)
+ 			    !strncmp(name, "nisplus:", 8) ||
+ 			    !strncmp(name, "ldap:", 5) ||
+ 			    !strncmp(name, "ldaps:", 6) ||
++			    !strncmp(name, "sss:", 4) ||
+ 			    !strncmp(name, "dir:", 4)) {
+ 				strncpy(source, name, tmp - name);
+ 
+diff --git a/lib/master_tok.l b/lib/master_tok.l
+index 77e9a26..0d6edb7 100644
+--- a/lib/master_tok.l
++++ b/lib/master_tok.l
+@@ -118,7 +118,7 @@ DNNAMESTR2	([[:alnum:]_.\-]+)
+ INTMAP		(-hosts|-null)
+ MULTI		((multi)(,(sun|hesiod))?(:{OPTWS}|{WS}))
+ MULTISEP	([\-]{2}[[:blank:]]+)
+-MTYPE		((file|program|yp|nis|nisplus|ldap|ldaps|hesiod|userdir)(,(sun|hesiod))?(:{OPTWS}|{WS}))
++MTYPE		((file|program|sss|yp|nis|nisplus|ldap|ldaps|hesiod|userdir)(,(sun|hesiod))?(:{OPTWS}|{WS}))
+ 
+ 
+ OPTTOUT		(-t{OPTWS}|-t{OPTWS}={OPTWS}|--timeout{OPTWS}|--timeout{OPTWS}={OPTWS})
+diff --git a/lib/nss_parse.y b/lib/nss_parse.y
+index 3bda6b3..a39fda4 100644
+--- a/lib/nss_parse.y
++++ b/lib/nss_parse.y
+@@ -82,7 +82,8 @@ nss_source: SOURCE
+ {
+ 	if (!strcmp($1, "files") || !strcmp($1, "yp") ||
+ 	    !strcmp($1, "nis") || !strcmp($1, "ldap") ||
+-	    !strcmp($1, "nisplus") || !strcmp($1, "hesiod"))
++	    !strcmp($1, "nisplus") || !strcmp($1, "hesiod") ||
++	    !strcmp($1, "sss"))
+ 		src = add_source(nss_list, $1);
+ 	else
+ 		nss_ignore($1);
+@@ -92,7 +93,8 @@ nss_source: SOURCE
+ 
+ 	if (!strcmp($1, "files") || !strcmp($1, "yp") ||
+ 	    !strcmp($1, "nis") || !strcmp($1, "ldap") ||
+-	    !strcmp($1, "nisplus") || !strcmp($1, "hesiod")) {
++	    !strcmp($1, "nisplus") || !strcmp($1, "hesiod") ||
++	    !strcmp($1, "sss")) {
+ 		src = add_source(nss_list, $1);
+ 		for (a = 0; a < NSS_STATUS_MAX; a++) {
+ 			if (act[a].action != NSS_ACTION_UNKNOWN) {
+diff --git a/modules/parse_sun.c b/modules/parse_sun.c
+index e9d94c7..d7e74e2 100644
+--- a/modules/parse_sun.c
++++ b/modules/parse_sun.c
+@@ -880,7 +880,7 @@ static int validate_location(unsigned int logopt, char *loc)
+ 		    !strncmp(ptr, "file:", 5) || !strncmp(ptr, "yp:", 3) ||
+ 		    !strncmp(ptr, "nis:", 4) || !strncmp(ptr, "nisplus:", 8) ||
+ 		    !strncmp(ptr, "ldap:", 5) || !strncmp(ptr, "ldaps:", 6) ||
+-		    !strncmp(ptr, "dir:", 4))
++		    !strncmp(ptr, "sss:", 4) || !strncmp(ptr, "dir:", 4))
+ 			return 1;
+ 		error(logopt,
+ 		      "expected colon delimeter not found in location %s",
Index: backfire/feeds/packages/utils/autofs/patches/127-autofs-5.0.6-fix-init-script-usage-message.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/127-autofs-5.0.6-fix-init-script-usage-message.patch
@@ -0,0 +1,62 @@
+autofs-5.0.6 - fix init script usage message
+
+From: Ian Kent <ikent@redhat.com>
+
+Changes made to the autofs init script based on lsb compliance resulted
+in a stupid change where the init script requires users to type:
+
+/sbin/service autofs usage
+
+to show proper usage.
+
+Maybe it was a misunderstanding of the lsb documentation but it is still
+not sensible. Change to issue the usage message when an umknown parameter
+is passed but retain the return codes.
+---
+
+ CHANGELOG             |    1 +
+ redhat/autofs.init.in |    8 ++++++--
+ 2 files changed, 7 insertions(+), 2 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index e276396..9087fbb 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -25,6 +25,7 @@
+ - fix fix wait for master source mutex.
+ - add sss lookup module.
+ - teach automount about sss source.
++- fix init script usage message.
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/redhat/autofs.init.in b/redhat/autofs.init.in
+index 38b9eeb..0f4a16a 100644
+--- a/redhat/autofs.init.in
++++ b/redhat/autofs.init.in
+@@ -151,6 +151,10 @@ function reload() {
+ 	return $RETVAL
+ }
+ 
++function usage_message() {
++	echo $"Usage: $0 {start|forcestart|stop|status|restart|force-reload|forcerestart|reload|condrestart|try-restart}"
++}
++
+ RETVAL=0
+ 
+ # Only the root user may change the service status
+@@ -189,11 +193,11 @@ case "$1" in
+ 		fi
+ 		;;
+ 	usage)
+-		echo $"Usage: $0 {start|forcestart|stop|status|restart|force-reload|forcerestart|reload|condrestart|try-restart}"
++		usage_message
+ 		exit 0
+ 		;;
+ 	*)
+-		echo "unknown, invalid or excess argument(s)"
++		usage_message
+ 		exit 2
+ 		;;
+ esac
Index: backfire/feeds/packages/utils/autofs/patches/128-autofs-5.0.6-ignore-duplicate-exports-in-auto.net.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/128-autofs-5.0.6-ignore-duplicate-exports-in-auto.net.patch
@@ -0,0 +1,37 @@
+autofs-5.0.6 - ignore duplicate exports in auto.net
+
+From: Paul Smith <pds at us.ibm.com>
+
+
+---
+
+ CHANGELOG        |    1 +
+ samples/auto.net |    2 +-
+ 2 files changed, 2 insertions(+), 1 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index 9087fbb..29e4049 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -26,6 +26,7 @@
+ - add sss lookup module.
+ - teach automount about sss source.
+ - fix init script usage message.
++- ignore duplicate exports in auto.net.
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/samples/auto.net b/samples/auto.net
+index ba03447..86b8505 100755
+--- a/samples/auto.net
++++ b/samples/auto.net
+@@ -35,7 +35,7 @@ done
+ # Newer distributions get this right
+ SHOWMOUNT="$SMNT --no-headers -e $key"
+ 
+-$SHOWMOUNT | LC_ALL=C sort -k 1 | \
++$SHOWMOUNT | LC_ALL=C cut -d' ' -f1 | LC_ALL=C sort -u | \
+ 	awk -v key="$key" -v opts="$opts" -- '
+ 	BEGIN	{ ORS=""; first=1 }
+ 		{ if (first) { print opts; first=0 }; print " \\\n\t" $1, key ":" $1 }
Index: backfire/feeds/packages/utils/autofs/patches/129-autofs-5.0.6-add-kernel-verion-check-function.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/129-autofs-5.0.6-add-kernel-verion-check-function.patch
@@ -0,0 +1,59 @@
+autofs-5.0.6 - add kernel verion check function
+
+From: Ian Kent <ikent@redhat.com>
+
+Add a function to check kernel version.
+---
+
+ CHANGELOG        |    1 +
+ include/mounts.h |   17 +++++++++++++++++
+ 2 files changed, 18 insertions(+), 0 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index 29e4049..7e5783f 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -27,6 +27,7 @@
+ - teach automount about sss source.
+ - fix init script usage message.
+ - ignore duplicate exports in auto.net.
++- add kernel verion check function.
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/include/mounts.h b/include/mounts.h
+index 4d932ca..3947d83 100644
+--- a/include/mounts.h
++++ b/include/mounts.h
+@@ -16,6 +16,9 @@
+ #ifndef MOUNTS_H
+ #define MOUNTS_H
+ 
++#include <linux/version.h>
++#include <sys/utsname.h>
++
+ #ifndef AUTOFS_TYPE_ANY
+ #define AUTOFS_TYPE_ANY		0x0000
+ #endif
+@@ -72,6 +75,20 @@ struct mnt_list {
+ 	struct list_head ordered;
+ };
+ 
++static inline unsigned int linux_version_code(void)
++{
++        struct utsname my_utsname;
++        unsigned int p, q, r;
++
++        if (uname(&my_utsname))
++                return 0;
++
++        p = (unsigned int)atoi(strtok(my_utsname.release, "."));
++        q = (unsigned int)atoi(strtok(NULL, "."));
++        r = (unsigned int)atoi(strtok(NULL, "."));
++        return KERNEL_VERSION(p, q, r);
++}
++
+ unsigned int query_kproto_ver(void);
+ unsigned int get_kver_major(void);
+ unsigned int get_kver_minor(void);
Index: backfire/feeds/packages/utils/autofs/patches/130-autofs-5.0.6-add-function-to-check-mount-nfs-version.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/130-autofs-5.0.6-add-function-to-check-mount-nfs-version.patch
@@ -0,0 +1,335 @@
+autofs-5.0.6 - add function to check mount.nfs version
+
+From: Ian Kent <ikent@redhat.com>
+
+Add a function to check if the mount.nfs version is greater than or
+equal to a given version.
+---
+
+ CHANGELOG           |    1 
+ configure           |   62 ++++++++++++++++++++++
+ configure.in        |    1 
+ include/config.h.in |    6 ++
+ include/mounts.h    |    7 ++
+ lib/mounts.c        |  147 +++++++++++++++++++++++++++++++++++++++++++++++++++
+ 6 files changed, 224 insertions(+), 0 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index 7e5783f..359c293 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -28,6 +28,7 @@
+ - fix init script usage message.
+ - ignore duplicate exports in auto.net.
+ - add kernel verion check function.
++- add function to check mount.nfs version.
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/configure b/configure
+index f78b322..ec394e7 100755
+--- a/configure
++++ b/configure
+@@ -645,6 +645,8 @@ HAVE_E2FSCK
+ E2FSCK
+ HAVE_UMOUNT
+ UMOUNT
++HAVE_MOUNT_NFS
++MOUNT_NFS
+ HAVE_MOUNT
+ MOUNT
+ DMALLOCLIB
+@@ -3248,6 +3250,66 @@ else
+   HAVE_MOUNT=0
+ fi
+ 
++for ac_prog in mount.nfs
++do
++  # Extract the first word of "$ac_prog", so it can be a program name with args.
++set dummy $ac_prog; ac_word=$2
++{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
++$as_echo_n "checking for $ac_word... " >&6; }
++if ${ac_cv_path_MOUNT_NFS+:} false; then :
++  $as_echo_n "(cached) " >&6
++else
++  case $MOUNT_NFS in
++  [\\/]* | ?:[\\/]*)
++  ac_cv_path_MOUNT_NFS="$MOUNT_NFS" # Let the user override the test with a path.
++  ;;
++  *)
++  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
++for as_dir in $searchpath
++do
++  IFS=$as_save_IFS
++  test -z "$as_dir" && as_dir=.
++    for ac_exec_ext in '' $ac_executable_extensions; do
++  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
++    ac_cv_path_MOUNT_NFS="$as_dir/$ac_word$ac_exec_ext"
++    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
++    break 2
++  fi
++done
++  done
++IFS=$as_save_IFS
++
++  ;;
++esac
++fi
++MOUNT_NFS=$ac_cv_path_MOUNT_NFS
++if test -n "$MOUNT_NFS"; then
++  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MOUNT_NFS" >&5
++$as_echo "$MOUNT_NFS" >&6; }
++else
++  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
++$as_echo "no" >&6; }
++fi
++
++
++  test -n "$MOUNT_NFS" && break
++done
++test -n "$MOUNT_NFS" || MOUNT_NFS="/sbin/mount.nfs "
++
++if test -n "$MOUNT_NFS"; then
++
++$as_echo "#define HAVE_MOUNT_NFS 1" >>confdefs.h
++
++
++cat >>confdefs.h <<_ACEOF
++#define PATH_MOUNT_NFS "$MOUNT_NFS"
++_ACEOF
++
++  HAVE_MOUNT_NFS=1
++else
++  HAVE_MOUNT_NFS=0
++fi
++
+ for ac_prog in umount
+ do
+   # Extract the first word of "$ac_prog", so it can be a program name with args.
+diff --git a/configure.in b/configure.in
+index c017829..5477508 100644
+--- a/configure.in
++++ b/configure.in
+@@ -137,6 +137,7 @@ AC_SUBST(DMALLOCLIB)
+ # Programs needed for various system functions or modules
+ #
+ AF_PATH_INCLUDE(MOUNT, mount, /bin/mount, $searchpath)
++AF_PATH_INCLUDE(MOUNT_NFS, mount.nfs, /sbin/mount.nfs , $searchpath)
+ AF_PATH_INCLUDE(UMOUNT, umount, /bin/umount, $searchpath)
+ AF_PATH_INCLUDE(E2FSCK, fsck.ext2 e2fsck, , $searchpath)
+ AF_PATH_INCLUDE(E3FSCK, fsck.ext3 e3fsck, , $searchpath)
+diff --git a/include/config.h.in b/include/config.h.in
+index fb4aadb..f79d579 100644
+--- a/include/config.h.in
++++ b/include/config.h.in
+@@ -45,6 +45,9 @@
+ /* define if you have MOUNT */
+ #undef HAVE_MOUNT
+ 
++/* define if you have MOUNT_NFS */
++#undef HAVE_MOUNT_NFS
++
+ /* define if the mount command supports the -s option */
+ #undef HAVE_SLOPPY_MOUNT
+ 
+@@ -111,6 +114,9 @@
+ /* define if you have MOUNT */
+ #undef PATH_MOUNT
+ 
++/* define if you have MOUNT_NFS */
++#undef PATH_MOUNT_NFS
++
+ /* define if you have RANLIB */
+ #undef PATH_RANLIB
+ 
+diff --git a/include/mounts.h b/include/mounts.h
+index 3947d83..6a6ebab 100644
+--- a/include/mounts.h
++++ b/include/mounts.h
+@@ -89,6 +89,13 @@ static inline unsigned int linux_version_code(void)
+         return KERNEL_VERSION(p, q, r);
+ }
+ 
++struct nfs_mount_vers {
++	unsigned int major;
++	unsigned int minor;
++	unsigned int fix;
++};
++int check_nfs_mount_version(struct nfs_mount_vers *, struct nfs_mount_vers *);
++
+ unsigned int query_kproto_ver(void);
+ unsigned int get_kver_major(void);
+ unsigned int get_kver_minor(void);
+diff --git a/lib/mounts.c b/lib/mounts.c
+index f26579e..efe0438 100644
+--- a/lib/mounts.c
++++ b/lib/mounts.c
+@@ -19,6 +19,8 @@
+ #include <sys/stat.h>
+ #include <sys/ioctl.h>
+ #include <sys/mount.h>
++#include <sys/wait.h>
++#include <ctype.h>
+ #include <stdio.h>
+ #include <dirent.h>
+ #include <sys/vfs.h>
+@@ -30,6 +32,8 @@
+ #define MAX_OPTIONS_LEN		80
+ #define MAX_MNT_NAME_LEN	30
+ 
++#define EBUFSIZ 1024
++
+ const unsigned int t_indirect = AUTOFS_TYPE_INDIRECT;
+ const unsigned int t_direct = AUTOFS_TYPE_DIRECT;
+ const unsigned int t_offset = AUTOFS_TYPE_OFFSET;
+@@ -131,6 +135,149 @@ unsigned int get_kver_minor(void)
+ 	return kver.minor;
+ }
+ 
++#ifdef HAVE_MOUNT_NFS
++static int extract_version(char *start, struct nfs_mount_vers *vers)
++{
++	char *s_ver = strchr(start, ' ');
++	while (*s_ver && !isdigit(*s_ver)) {
++		s_ver++;
++		if (!*s_ver)
++			return 0;
++		break;
++	}
++	vers->major = atoi(strtok(s_ver, "."));
++	vers->minor = (unsigned int) atoi(strtok(NULL, "."));
++	vers->fix = (unsigned int) atoi(strtok(NULL, "."));
++	return 1;
++}
++
++int check_nfs_mount_version(struct nfs_mount_vers *vers,
++			    struct nfs_mount_vers *check)
++{
++	pid_t f;
++	int ret, status, pipefd[2];
++	char errbuf[EBUFSIZ + 1], *p, *sp;
++	int errp, errn;
++	sigset_t allsigs, tmpsig, oldsig;
++	char *s_ver;
++	int cancel_state;
++
++	if (pipe(pipefd))
++		return -1;
++
++	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cancel_state);
++
++	sigfillset(&allsigs);
++	pthread_sigmask(SIG_BLOCK, &allsigs, &oldsig);
++
++	f = fork();
++	if (f == 0) {
++		reset_signals();
++		close(pipefd[0]);
++		dup2(pipefd[1], STDOUT_FILENO);
++		dup2(pipefd[1], STDERR_FILENO);
++		close(pipefd[1]);
++
++		execl(PATH_MOUNT_NFS, PATH_MOUNT_NFS, "-V", (char *) NULL);
++		_exit(255);	/* execv() failed */
++	}
++
++	ret = 0;
++
++	tmpsig = oldsig;
++
++	sigaddset(&tmpsig, SIGCHLD);
++	pthread_sigmask(SIG_SETMASK, &tmpsig, NULL);
++
++	close(pipefd[1]);
++
++	if (f < 0) {
++		close(pipefd[0]);
++		pthread_sigmask(SIG_SETMASK, &oldsig, NULL);
++		pthread_setcancelstate(cancel_state, NULL);
++		return -1;
++	}
++
++	errp = 0;
++	do {
++		while (1) {
++			errn = read(pipefd[0], errbuf + errp, EBUFSIZ - errp);
++			if (errn == -1 && errno == EINTR)
++				continue;
++			break;
++		}
++
++		if (errn > 0) {
++			errp += errn;
++
++			sp = errbuf;
++			while (errp && (p = memchr(sp, '\n', errp))) {
++				*p++ = '\0';
++				errp -= (p - sp);
++				sp = p;
++			}
++
++			if (errp && sp != errbuf)
++				memmove(errbuf, sp, errp);
++
++			if (errp >= EBUFSIZ) {
++				/* Line too long, split */
++				errbuf[errp] = '\0';
++				if ((s_ver = strstr(errbuf, "nfs-utils"))) {
++					if (extract_version(s_ver, vers))
++						ret = 1;
++				}
++				errp = 0;
++			}
++
++			if ((s_ver = strstr(errbuf, "nfs-utils"))) {
++				if (extract_version(s_ver, vers))
++					ret = 1;
++			}
++		}
++	} while (errn > 0);
++
++	close(pipefd[0]);
++
++	if (errp > 0) {
++		/* End of file without \n */
++		errbuf[errp] = '\0';
++		if ((s_ver = strstr(errbuf, "nfs-utils"))) {
++			if (extract_version(s_ver, vers))
++				ret = 1;
++		}
++	}
++
++	if (ret) {
++		if (vers->major == check->major &&
++		    vers->minor == check->minor &&
++		    vers->fix == check->fix)
++			;
++		else {
++			if (vers->major < check->major)
++				ret = 0;
++			else if (vers->minor < check->minor)
++				ret = 0;
++			else if (vers->fix < check->fix)
++				ret = 0;
++		}
++	}
++
++	if (waitpid(f, &status, 0) != f) ;
++
++	pthread_sigmask(SIG_SETMASK, &oldsig, NULL);
++	pthread_setcancelstate(cancel_state, NULL);
++
++	return ret;
++}
++#else
++int check_nfs_mount_version(struct nfs_mount_vers *vers,
++			    struct nfs_mount_vers *check)
++{
++	return 0;
++}
++#endif
++
+ /*
+  * Make common autofs mount options string
+  */
Index: backfire/feeds/packages/utils/autofs/patches/131-autofs-5.0.6-reinstate-singleton-mount-probe.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/131-autofs-5.0.6-reinstate-singleton-mount-probe.patch
@@ -0,0 +1,113 @@
+autofs-5.0.6 - reinstate singleton mount probe
+
+From: Ian Kent <ikent@redhat.com>
+
+The change to have the kernel process text based mount options can
+introduce lengthy timeout waits when attempting a mount to a host
+that is not available.
+
+To avoid these waits autofs should probe singleton mounts if it
+thinks mount.nfs will pass text options to the kernel (which of
+course implies the kernel supports this).
+---
+
+ CHANGELOG            |    1 +
+ daemon/automount.c   |    7 +++++++
+ include/mounts.h     |    1 +
+ modules/replicated.c |   18 ++++++++++++++++--
+ 4 files changed, 25 insertions(+), 2 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index 359c293..5a6af1c 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -29,6 +29,7 @@
+ - ignore duplicate exports in auto.net.
+ - add kernel verion check function.
+ - add function to check mount.nfs version.
++- reinstate singleton mount probe.
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/daemon/automount.c b/daemon/automount.c
+index c0b4b85..31dd564 100644
+--- a/daemon/automount.c
++++ b/daemon/automount.c
+@@ -51,6 +51,9 @@ const char *libdir = AUTOFS_LIB_DIR;	/* Location of library modules */
+ const char *mapdir = AUTOFS_MAP_DIR;	/* Location of mount maps */
+ const char *confdir = AUTOFS_CONF_DIR;	/* Location of autofs config file */
+ 
++unsigned int nfs_mount_uses_string_options = 0;
++static struct nfs_mount_vers vers, check = {1, 1, 1};
++
+ /* autofs fifo name prefix */
+ const char *fifodir = AUTOFS_FIFO_DIR "/autofs.fifo";
+ 
+@@ -1273,6 +1276,8 @@ static int do_hup_signal(struct master *master, time_t age)
+ 	if (status)
+ 		fatal(status);
+ 
++	nfs_mount_uses_string_options = check_nfs_mount_version(&vers, &check);
++
+ 	master_mutex_lock();
+ 	if (master->reading) {
+ 		status = pthread_mutex_unlock(&mrc.mutex);
+@@ -1936,6 +1941,8 @@ int main(int argc, char *argv[])
+ 
+ 	defaults_read_config(0);
+ 
++	nfs_mount_uses_string_options = check_nfs_mount_version(&vers, &check);
++
+ 	kpkt_len = get_kpkt_len();
+ 	timeout = defaults_get_timeout();
+ 	ghost = defaults_get_browse_mode();
+diff --git a/include/mounts.h b/include/mounts.h
+index 6a6ebab..9aac90f 100644
+--- a/include/mounts.h
++++ b/include/mounts.h
+@@ -95,6 +95,7 @@ struct nfs_mount_vers {
+ 	unsigned int fix;
+ };
+ int check_nfs_mount_version(struct nfs_mount_vers *, struct nfs_mount_vers *);
++extern unsigned int nfs_mount_uses_string_options;
+ 
+ unsigned int query_kproto_ver(void);
+ unsigned int get_kver_major(void);
+diff --git a/modules/replicated.c b/modules/replicated.c
+index 65634bd..84134b6 100644
+--- a/modules/replicated.c
++++ b/modules/replicated.c
+@@ -901,6 +901,7 @@ int prune_host_list(unsigned logopt, struct host **list,
+ 	unsigned int v2_udp_count, v3_udp_count, v4_udp_count;
+ 	unsigned int max_udp_count, max_tcp_count, max_count;
+ 	int status;
++	int kern_vers;
+ 
+ 	if (!*list)
+ 		return 0;
+@@ -920,9 +921,22 @@ int prune_host_list(unsigned logopt, struct host **list,
+ 	 * or a single host entry whose proximity isn't local. If so
+ 	 * return immediately as we don't want to add probe latency for
+ 	 * the common case of a single filesystem mount request.
++	 *
++	 * But, if the kernel understands text nfs mount options then
++	 * mount.nfs most likely bypasses its probing and lets the kernel
++	 * do all the work. This can lead to long timeouts for hosts that
++	 * are not available so check the kernel version and mount.nfs
++	 * version and probe singleton mounts if the kernel version is
++	 * greater than 2.6.22 and mount.nfs version is greater than 1.1.1.
+ 	 */
+-	if (!this || !this->next)
+-		return 1;
++	if (nfs_mount_uses_string_options &&
++	   (kern_vers = linux_version_code()) > KERNEL_VERSION(2, 6, 22)) {
++		if (!this)
++			return 1;
++	} else {
++		if (!this || !this->next)
++			return 1;
++	}
+ 
+ 	proximity = this->proximity;
+ 	while (this) {
Index: backfire/feeds/packages/utils/autofs/patches/132-autofs-5.0.6-rework-error-return-handling-in-rpc-code.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/132-autofs-5.0.6-rework-error-return-handling-in-rpc-code.patch
@@ -0,0 +1,623 @@
+autofs-5.0.6 - rework error return handling in rpc code
+
+From: Ian Kent <raven@themaw.net>
+
+With the changes to the way mount.nfs performs nfs mounts for
+kernels that support passing of text based options mounts to
+hosts that are down or unreachable can take a long time to
+fail due to lengthy timeouts. The kernel rpc code is duty
+bound to honour these timeouts so we need to find a way to
+catch EHOSTUNREACH errors during host probing.
+
+The first thing to do is to rework the lower level autofs
+rpc code to propogate error returns up to the higher levels.
+---
+
+ CHANGELOG            |    1 
+ lib/rpc_subs.c       |  176 ++++++++++++++++++++++++++++----------------------
+ modules/replicated.c |   26 ++++---
+ 3 files changed, 113 insertions(+), 90 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index 5a6af1c..c581099 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -30,6 +30,7 @@
+ - add kernel verion check function.
+ - add function to check mount.nfs version.
+ - reinstate singleton mount probe.
++- rework error return handling in rpc code.
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/lib/rpc_subs.c b/lib/rpc_subs.c
+index 4082fee..21f090a 100644
+--- a/lib/rpc_subs.c
++++ b/lib/rpc_subs.c
+@@ -76,11 +76,11 @@ static int connect_nb(int fd, struct sockaddr *addr, socklen_t len, struct timev
+ 
+ 	flags = fcntl(fd, F_GETFL, 0);
+ 	if (flags < 0)
+-		return -1;
++		return -errno;
+ 
+ 	ret = fcntl(fd, F_SETFL, flags | O_NONBLOCK);
+ 	if (ret < 0)
+-		return -1;
++		return -errno;
+ 
+ 	/* 
+ 	 * From here on subsequent sys calls could change errno so
+@@ -150,14 +150,16 @@ done:
+ }
+ 
+ #ifndef WITH_LIBTIRPC
+-static CLIENT *rpc_do_create_client(struct sockaddr *addr, struct conn_info *info, int *fd)
++static int rpc_do_create_client(struct sockaddr *addr, struct conn_info *info, int *fd, CLIENT **client)
+ {
+-	CLIENT *client = NULL;
++	CLIENT *clnt = NULL;
+ 	struct sockaddr_in in4_laddr;
+ 	struct sockaddr_in *in4_raddr;
+ 	int type, proto;
+ 	socklen_t slen;
+ 
++	*client = NULL;
++
+ 	proto = info->proto->p_proto;
+ 	if (proto == IPPROTO_UDP)
+ 		type = SOCK_DGRAM;
+@@ -179,11 +181,11 @@ static CLIENT *rpc_do_create_client(struct sockaddr *addr, struct conn_info *inf
+ 
+ 		*fd = open_sock(addr->sa_family, type, proto);
+ 		if (*fd < 0)
+-			return NULL;
++			return -errno;
+ 
+ 		laddr = (struct sockaddr *) &in4_laddr;
+ 		if (bind(*fd, laddr, slen) < 0)
+-			return NULL;
++			return -errno;
+ 	}
+ 
+ 	in4_raddr = (struct sockaddr_in *) addr;
+@@ -191,26 +193,29 @@ static CLIENT *rpc_do_create_client(struct sockaddr *addr, struct conn_info *inf
+ 
+ 	switch (info->proto->p_proto) {
+ 	case IPPROTO_UDP:
+-		client = clntudp_bufcreate(in4_raddr,
+-					   info->program, info->version,
+-					   info->timeout, fd,
+-					   info->send_sz, info->recv_sz);
++		clnt = clntudp_bufcreate(in4_raddr,
++					 info->program, info->version,
++					 info->timeout, fd,
++					 info->send_sz, info->recv_sz);
+ 		break;
+ 
+ 	case IPPROTO_TCP:
+-		if (connect_nb(*fd, addr, slen, &info->timeout) < 0)
+-			break;
++		int ret = connect_nb(*fd, addr, slen, &info->timeout);
++		if (ret < 0)
++			return ret;
+ 
+-		client = clnttcp_create(in4_raddr,
+-					info->program, info->version, fd,
+-					info->send_sz, info->recv_sz);
++		clnt = clnttcp_create(in4_raddr,
++				      info->program, info->version, fd,
++				      info->send_sz, info->recv_sz);
+ 		break;
+ 
+ 	default:
+ 		break;
+ 	}
+ 
+-	return client;
++	*client = clnt;
++
++	return 0;
+ }
+ #else
+ struct netconfig *find_netconf(void *handle, char *family, char *proto)
+@@ -226,9 +231,9 @@ struct netconfig *find_netconf(void *handle, char *family, char *proto)
+ 	return nconf;
+ }
+ 
+-static CLIENT *rpc_do_create_client(struct sockaddr *addr, struct conn_info *info, int *fd)
++static int rpc_do_create_client(struct sockaddr *addr, struct conn_info *info, int *fd, CLIENT **client)
+ {
+-	CLIENT *client = NULL;
++	CLIENT *clnt = NULL;
+ 	struct sockaddr_in in4_laddr;
+ 	struct sockaddr_in6 in6_laddr;
+ 	struct sockaddr *laddr = NULL;
+@@ -238,6 +243,9 @@ static CLIENT *rpc_do_create_client(struct sockaddr *addr, struct conn_info *inf
+ 	char *nc_family, *nc_proto;
+ 	void *handle;
+ 	size_t slen;
++	int ret;
++
++	*client = NULL;
+ 
+ 	proto = info->proto->p_proto;
+ 	if (proto == IPPROTO_UDP) {
+@@ -272,16 +280,16 @@ static CLIENT *rpc_do_create_client(struct sockaddr *addr, struct conn_info *inf
+ 		slen = sizeof(struct sockaddr_in6);
+ 		nc_family = NC_INET6;
+ 	} else
+-		return NULL;
++		return -EINVAL;
+ 
+ 	handle = setnetconfig();
+ 	if (!handle)
+-		return NULL;
++		return -EINVAL;
+ 
+ 	nconf = find_netconf(handle, nc_family, nc_proto);
+ 	if (!nconf) {
+ 		endnetconfig(handle);
+-		return NULL;
++		return -EINVAL;
+ 	}
+ 
+ 	/*
+@@ -292,13 +300,15 @@ static CLIENT *rpc_do_create_client(struct sockaddr *addr, struct conn_info *inf
+ 	if (!info->client) {
+ 		*fd = open_sock(addr->sa_family, type, proto);
+ 		if (*fd < 0) {
++			ret = -errno;
+ 			endnetconfig(handle);
+-			return NULL;
++			return ret;
+ 		}
+ 
+ 		if (bind(*fd, laddr, slen) < 0) {
++			ret = -errno;
+ 			endnetconfig(handle);
+-			return NULL;
++			return ret;
+ 		}
+ 	}
+ 
+@@ -306,28 +316,30 @@ static CLIENT *rpc_do_create_client(struct sockaddr *addr, struct conn_info *inf
+ 	nb_addr.buf = addr;
+ 
+ 	if (info->proto->p_proto == IPPROTO_TCP) {
+-		if (connect_nb(*fd, addr, slen, &info->timeout) < 0) {
++		ret = connect_nb(*fd, addr, slen, &info->timeout);
++		if (ret < 0) {
+ 			endnetconfig(handle);
+-			return NULL;
++			return ret;
+ 		}
+ 	}
+ 
+-	client = clnt_tli_create(*fd, nconf, &nb_addr,
+-				 info->program, info->version,
+-				 info->send_sz, info->recv_sz);
++	clnt = clnt_tli_create(*fd, nconf, &nb_addr,
++				info->program, info->version,
++				info->send_sz, info->recv_sz);
+ 
+ 	endnetconfig(handle);
+ 
+-	return client;
++	*client = clnt;
++
++	return 0;
+ }
+ #endif
+ 
+ /*
+  * Create an RPC client
+  */
+-static CLIENT *create_client(struct conn_info *info)
++static int create_client(struct conn_info *info, CLIENT **client)
+ {
+-	CLIENT *client = NULL;
+ 	struct addrinfo *ai, *haddr;
+ 	struct addrinfo hints;
+ 	int fd, ret;
+@@ -346,9 +358,11 @@ static CLIENT *create_client(struct conn_info *info)
+ 	}
+ 
+ 	if (info->addr) {
+-		client = rpc_do_create_client(info->addr, info, &fd);
+-		if (client)
++		ret = rpc_do_create_client(info->addr, info, &fd, client);
++		if (ret == 0)
+ 			goto done;
++		if (ret == -EHOSTUNREACH)
++			goto out_close;
+ 
+ 		if (!info->client && fd != RPC_ANYSOCK) {
+ 			close(fd);
+@@ -376,9 +390,11 @@ static CLIENT *create_client(struct conn_info *info)
+ 			continue;
+ 		}
+ 
+-		client = rpc_do_create_client(haddr->ai_addr, info, &fd);
+-		if (client)
++		ret = rpc_do_create_client(haddr->ai_addr, info, &fd, client);
++		if (ret == 0)
+ 			break;
++		if (ret == -EHOSTUNREACH)
++			goto out_close;
+ 
+ 		if (!info->client && fd != RPC_ANYSOCK) {
+ 			close(fd);
+@@ -390,24 +406,26 @@ static CLIENT *create_client(struct conn_info *info)
+ 
+ 	freeaddrinfo(ai);
+ 
+-	if (!client) {
++	if (!*client) {
+ 		info->client = NULL;
++		ret = -ENOTCONN;
+ 		goto out_close;
+ 	}
+ done:
+ 	/* Close socket fd on destroy, as is default for rpcowned fds */
+-	if  (!clnt_control(client, CLSET_FD_CLOSE, NULL)) {
+-		clnt_destroy(client);
++	if  (!clnt_control(*client, CLSET_FD_CLOSE, NULL)) {
++		clnt_destroy(*client);
+ 		info->client = NULL;
++		ret = -ENOTCONN;
+ 		goto out_close;
+ 	}
+ 
+-	return client;
++	return 0;
+ 
+ out_close:
+ 	if (fd != -1)
+ 		close(fd);
+-	return NULL;
++	return ret;
+ }
+ 
+ int rpc_udp_getclient(struct conn_info *info,
+@@ -415,11 +433,12 @@ int rpc_udp_getclient(struct conn_info *info,
+ {
+ 	struct protoent *pe_proto;
+ 	CLIENT *client;
++	int ret;
+ 
+ 	if (!info->client) {
+ 		pe_proto = getprotobyname("udp");
+ 		if (!pe_proto)
+-			return 0;
++			return -ENOENT;
+ 
+ 		info->proto = pe_proto;
+ 		info->send_sz = UDPMSGSIZE;
+@@ -429,14 +448,13 @@ int rpc_udp_getclient(struct conn_info *info,
+ 	info->program = program;
+ 	info->version = version;
+ 
+-	client = create_client(info);
+-
+-	if (!client)
+-		return 0;
++	ret = create_client(info, &client);
++	if (ret < 0)
++		return ret;
+ 
+ 	info->client = client;
+ 
+-	return 1;
++	return 0;
+ }
+ 
+ void rpc_destroy_udp_client(struct conn_info *info)
+@@ -454,11 +472,12 @@ int rpc_tcp_getclient(struct conn_info *info,
+ {
+ 	struct protoent *pe_proto;
+ 	CLIENT *client;
++	int ret;
+ 
+ 	if (!info->client) {
+ 		pe_proto = getprotobyname("tcp");
+ 		if (!pe_proto)
+-			return 0;
++			return -ENOENT;
+ 
+ 		info->proto = pe_proto;
+ 		info->send_sz = 0;
+@@ -468,14 +487,13 @@ int rpc_tcp_getclient(struct conn_info *info,
+ 	info->program = program;
+ 	info->version = version;
+ 
+-	client = create_client(info);
+-
+-	if (!client)
+-		return 0;
++	ret = create_client(info, &client);
++	if (ret < 0)
++		return ret;
+ 
+ 	info->client = client;
+ 
+-	return 1;
++	return 0;
+ }
+ 
+ void rpc_destroy_tcp_client(struct conn_info *info)
+@@ -509,10 +527,11 @@ int rpc_portmap_getclient(struct conn_info *info,
+ {
+ 	struct protoent *pe_proto;
+ 	CLIENT *client;
++	int ret;
+ 
+ 	pe_proto = getprotobyname(proto);
+ 	if (!pe_proto)
+-		return 0;
++		return -ENOENT;
+ 
+ 	info->host = host;
+ 	info->addr = addr;
+@@ -530,13 +549,14 @@ int rpc_portmap_getclient(struct conn_info *info,
+ 
+ 	if (pe_proto->p_proto == IPPROTO_TCP)
+ 		info->timeout.tv_sec = PMAP_TOUT_TCP;
+-	client = create_client(info);
+-	if (!client)
+-		return 0;
++
++	ret = create_client(info, &client);
++	if (ret < 0)
++		return ret;
+ 
+ 	info->client = client;
+ 
+-	return 1;
++	return 0;
+ }
+ 
+ unsigned short rpc_portmap_getport(struct conn_info *info, struct pmap *parms)
+@@ -546,6 +566,7 @@ unsigned short rpc_portmap_getport(struct conn_info *info, struct pmap *parms)
+ 	CLIENT *client;
+ 	enum clnt_stat status;
+ 	int proto = info->proto->p_proto;
++	int ret;
+ 
+ 	memset(&pmap_info, 0, sizeof(struct conn_info));
+ 
+@@ -567,9 +588,9 @@ unsigned short rpc_portmap_getport(struct conn_info *info, struct pmap *parms)
+ 		pmap_info.send_sz = RPCSMALLMSGSIZE;
+ 		pmap_info.recv_sz = RPCSMALLMSGSIZE;
+ 
+-		client = create_client(&pmap_info);
+-		if (!client)
+-			return 0;
++		ret = create_client(&pmap_info, &client);
++		if (ret < 0)
++			return ret;
+ 	}
+ 
+ 	/*
+@@ -611,7 +632,7 @@ unsigned short rpc_portmap_getport(struct conn_info *info, struct pmap *parms)
+ 	}
+ 
+ 	if (status != RPC_SUCCESS)
+-		return 0;
++		return -EIO;
+ 
+ 	return port;
+ }
+@@ -621,6 +642,7 @@ int rpc_ping_proto(struct conn_info *info)
+ 	CLIENT *client;
+ 	enum clnt_stat status;
+ 	int proto = info->proto->p_proto;
++	int ret;
+ 
+ 	if (info->client)
+ 		client = info->client;
+@@ -629,9 +651,9 @@ int rpc_ping_proto(struct conn_info *info)
+ 			info->send_sz = UDPMSGSIZE;
+ 			info->recv_sz = UDPMSGSIZE;
+ 		}
+-		client = create_client(info);
+-		if (!client)
+-			return 0;
++		ret = create_client(info, &client);
++		if (ret < 0)
++			return ret;
+ 	}
+ 
+ 	clnt_control(client, CLSET_TIMEOUT, (char *) &info->timeout);
+@@ -665,7 +687,7 @@ int rpc_ping_proto(struct conn_info *info)
+ 	}
+ 
+ 	if (status != RPC_SUCCESS)
+-		return 0;
++		return -EIO;
+ 
+ 	return 1;
+ }
+@@ -704,7 +726,7 @@ static unsigned int __rpc_ping(const char *host,
+ 	parms.pm_port = 0;
+ 
+ 	info.port = rpc_portmap_getport(&info, &parms);
+-	if (!info.port)
++	if (info.port < 0)
+ 		return status;
+ 
+ 	status = rpc_ping_proto(&info);
+@@ -719,19 +741,19 @@ int rpc_ping(const char *host, long seconds, long micros, unsigned int option)
+ 	unsigned int status;
+ 
+ 	status = __rpc_ping(host, vers2, "udp", seconds, micros, option);
+-	if (status)
++	if (status > 0)
+ 		return RPC_PING_V2 | RPC_PING_UDP;
+ 
+ 	status = __rpc_ping(host, vers3, "udp", seconds, micros, option);
+-	if (status)
++	if (status > 0)
+ 		return RPC_PING_V3 | RPC_PING_UDP;
+ 
+ 	status = __rpc_ping(host, vers2, "tcp", seconds, micros, option);
+-	if (status)
++	if (status > 0)
+ 		return RPC_PING_V2 | RPC_PING_TCP;
+ 
+ 	status = __rpc_ping(host, vers3, "tcp", seconds, micros, option);
+-	if (status)
++	if (status > 0)
+ 		return RPC_PING_V3 | RPC_PING_TCP;
+ 
+ 	return status;
+@@ -760,9 +782,8 @@ int rpc_time(const char *host,
+ 	status = __rpc_ping(host, vers, proto, seconds, micros, option);
+ 	gettimeofday(&end, &tz);
+ 
+-	if (!status) {
+-		return 0;
+-	}
++	if (status == RPC_PING_FAIL || status < 0)
++		return status;
+ 
+ 	taken = elapsed(start, end);
+ 
+@@ -779,13 +800,14 @@ static int rpc_get_exports_proto(struct conn_info *info, exports *exp)
+ 	int proto = info->proto->p_proto;
+ 	unsigned int option = info->close_option;
+ 	int vers_entry;
++	int ret;
+ 
+ 	if (info->proto->p_proto == IPPROTO_UDP) {
+ 		info->send_sz = UDPMSGSIZE;
+ 		info->recv_sz = UDPMSGSIZE;
+ 	}
+-	client = create_client(info);
+-	if (!client)
++	ret = create_client(info, &client);
++	if (ret < 0)
+ 		return 0;
+ 
+ 	clnt_control(client, CLSET_TIMEOUT, (char *) &info->timeout);
+@@ -894,7 +916,7 @@ exports rpc_get_exports(const char *host, long seconds, long micros, unsigned in
+ 	parms.pm_prot = info.proto->p_proto;
+ 
+ 	info.port = rpc_portmap_getport(&info, &parms);
+-	if (!info.port)
++	if (info.port < 0)
+ 		goto try_tcp;
+ 
+ 	memset(&exportlist, '\0', sizeof(exportlist));
+@@ -911,7 +933,7 @@ try_tcp:
+ 	parms.pm_prot = info.proto->p_proto;
+ 
+ 	info.port = rpc_portmap_getport(&info, &parms);
+-	if (!info.port)
++	if (info.port < 0)
+ 		return NULL;
+ 
+ 	memset(&exportlist, '\0', sizeof(exportlist));
+diff --git a/modules/replicated.c b/modules/replicated.c
+index 84134b6..ab8fdf3 100644
+--- a/modules/replicated.c
++++ b/modules/replicated.c
+@@ -563,11 +563,11 @@ static unsigned int get_nfs_info(unsigned logopt, struct host *host,
+ 		status = rpc_udp_getclient(rpc_info, NFS_PROGRAM, NFS4_VERSION);
+ 	else
+ 		status = rpc_tcp_getclient(rpc_info, NFS_PROGRAM, NFS4_VERSION);
+-	if (status) {
++	if (!status) {
+ 		gettimeofday(&start, &tz);
+ 		status = rpc_ping_proto(rpc_info);
+ 		gettimeofday(&end, &tz);
+-		if (status) {
++		if (status > 0) {
+ 			double reply;
+ 			if (random_selection) {
+ 				/* Random value between 0 and 1 */
+@@ -589,7 +589,7 @@ v3_ver:
+ 		status = rpc_portmap_getclient(pm_info,
+ 				host->name, host->addr, host->addr_len,
+ 				proto, RPC_CLOSE_DEFAULT);
+-		if (!status)
++		if (status)
+ 			goto done_ver;
+ 	}
+ 
+@@ -603,7 +603,7 @@ v3_ver:
+ 		parms.pm_prot = rpc_info->proto->p_proto;
+ 		parms.pm_vers = NFS3_VERSION;
+ 		rpc_info->port = rpc_portmap_getport(pm_info, &parms);
+-		if (!rpc_info->port)
++		if (rpc_info->port < 0)
+ 			goto v2_ver;
+ 	}
+ 
+@@ -611,11 +611,11 @@ v3_ver:
+ 		status = rpc_udp_getclient(rpc_info, NFS_PROGRAM, NFS3_VERSION);
+ 	else
+ 		status = rpc_tcp_getclient(rpc_info, NFS_PROGRAM, NFS3_VERSION);
+-	if (status) {
++	if (!status) {
+ 		gettimeofday(&start, &tz);
+ 		status = rpc_ping_proto(rpc_info);
+ 		gettimeofday(&end, &tz);
+-		if (status) {
++		if (status > 0) {
+ 			double reply;
+ 			if (random_selection) {
+ 				/* Random value between 0 and 1 */
+@@ -643,7 +643,7 @@ v2_ver:
+ 		parms.pm_prot = rpc_info->proto->p_proto;
+ 		parms.pm_vers = NFS2_VERSION;
+ 		rpc_info->port = rpc_portmap_getport(pm_info, &parms);
+-		if (!rpc_info->port)
++		if (rpc_info->port < 0)
+ 			goto done_ver;
+ 	}
+ 
+@@ -651,11 +651,11 @@ v2_ver:
+ 		status = rpc_udp_getclient(rpc_info, NFS_PROGRAM, NFS2_VERSION);
+ 	else
+ 		status = rpc_tcp_getclient(rpc_info, NFS_PROGRAM, NFS2_VERSION);
+-	if (status) {
++	if (!status) {
+ 		gettimeofday(&start, &tz);
+ 		status = rpc_ping_proto(rpc_info);
+ 		gettimeofday(&end, &tz);
+-		if (status) {
++		if (status > 0) {
+ 			double reply;
+ 			if (random_selection) {
+ 				/* Random value between 0 and 1 */
+@@ -835,12 +835,12 @@ static int get_supported_ver_and_cost(unsigned logopt, struct host *host,
+ 		int ret = rpc_portmap_getclient(&pm_info,
+ 				host->name, host->addr, host->addr_len,
+ 				proto, RPC_CLOSE_DEFAULT);
+-		if (!ret)
++		if (ret)
+ 			return 0;
+ 
+ 		parms.pm_prot = rpc_info.proto->p_proto;
+ 		rpc_info.port = rpc_portmap_getport(&pm_info, &parms);
+-		if (!rpc_info.port)
++		if (rpc_info.port < 0)
+ 			goto done;
+ 	}
+ 
+@@ -848,11 +848,11 @@ static int get_supported_ver_and_cost(unsigned logopt, struct host *host,
+ 		status = rpc_udp_getclient(&rpc_info, NFS_PROGRAM, parms.pm_vers);
+ 	else
+ 		status = rpc_tcp_getclient(&rpc_info, NFS_PROGRAM, parms.pm_vers);
+-	if (status) {
++	if (!status) {
+ 		gettimeofday(&start, &tz);
+ 		status = rpc_ping_proto(&rpc_info);
+ 		gettimeofday(&end, &tz);
+-		if (status) {
++		if (status > 0) {
+ 			if (random_selection) {
+ 				/* Random value between 0 and 1 */
+ 				taken = ((float) random())/((float) RAND_MAX+1);
Index: backfire/feeds/packages/utils/autofs/patches/133-autofs-5.0.6-catch-EHOSTUNREACH-and-bail-out-early.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/133-autofs-5.0.6-catch-EHOSTUNREACH-and-bail-out-early.patch
@@ -0,0 +1,172 @@
+autofs-5.0.6 - catch EHOSTUNREACH and bail out early
+
+From: Ian Kent <raven@themaw.net>
+
+Now that the lower layers of the rpc code has been reworked
+to propogate error returns up to the top level code we can
+catch the EHOSTUNREACH return and stop the probe since the
+host isn't responding.
+
+Also, since UDP is a broadcast protocol we don't get the
+EHOSTUNREACH and always have to wait, so change the probe
+order to try TCP first. Using UDP first was originally
+done to reduce reserved port usage but autofs probing uses
+higher numbered ports now so this shouldn't introduce
+problem even for older implementations.
+---
+
+ CHANGELOG            |    1 +
+ include/replicated.h |    3 +++
+ modules/replicated.c |   55 ++++++++++++++++++++++++++++++++++++--------------
+ 3 files changed, 44 insertions(+), 15 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index c581099..69ade49 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -31,6 +31,7 @@
+ - add function to check mount.nfs version.
+ - reinstate singleton mount probe.
+ - rework error return handling in rpc code.
++- catch EHOSTUNREACH and bail out early.
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/include/replicated.h b/include/replicated.h
+index 206918e..a143ccf 100644
+--- a/include/replicated.h
++++ b/include/replicated.h
+@@ -48,6 +48,9 @@
+ #define TCP_SELECTED_MASK	0x00FF
+ #define UDP_SELECTED_MASK	0xFF00
+ 
++#define IS_ERR(supported)	(0x8000 & supported)
++#define ERR(supported)		(IS_ERR(supported) ? (~supported + 1) : supported)
++
+ #define RPC_TIMEOUT		5
+ 
+ struct host {
+diff --git a/modules/replicated.c b/modules/replicated.c
+index ab8fdf3..e14c5da 100644
+--- a/modules/replicated.c
++++ b/modules/replicated.c
+@@ -563,7 +563,9 @@ static unsigned int get_nfs_info(unsigned logopt, struct host *host,
+ 		status = rpc_udp_getclient(rpc_info, NFS_PROGRAM, NFS4_VERSION);
+ 	else
+ 		status = rpc_tcp_getclient(rpc_info, NFS_PROGRAM, NFS4_VERSION);
+-	if (!status) {
++	if (status == -EHOSTUNREACH)
++		return (unsigned int) status;
++	else if (!status) {
+ 		gettimeofday(&start, &tz);
+ 		status = rpc_ping_proto(rpc_info);
+ 		gettimeofday(&end, &tz);
+@@ -589,7 +591,10 @@ v3_ver:
+ 		status = rpc_portmap_getclient(pm_info,
+ 				host->name, host->addr, host->addr_len,
+ 				proto, RPC_CLOSE_DEFAULT);
+-		if (status)
++		if (status == -EHOSTUNREACH) {
++			supported = status;
++			goto done_ver;
++		} else if (status)
+ 			goto done_ver;
+ 	}
+ 
+@@ -602,16 +607,23 @@ v3_ver:
+ 	} else {
+ 		parms.pm_prot = rpc_info->proto->p_proto;
+ 		parms.pm_vers = NFS3_VERSION;
+-		rpc_info->port = rpc_portmap_getport(pm_info, &parms);
+-		if (rpc_info->port < 0)
++		status = rpc_portmap_getport(pm_info, &parms);
++		if (status == -EHOSTUNREACH) {
++			supported = status;
++			goto done_ver;
++		} else if (status < 0)
+ 			goto v2_ver;
++		rpc_info->port = status;
+ 	}
+ 
+ 	if (rpc_info->proto->p_proto == IPPROTO_UDP)
+ 		status = rpc_udp_getclient(rpc_info, NFS_PROGRAM, NFS3_VERSION);
+ 	else
+ 		status = rpc_tcp_getclient(rpc_info, NFS_PROGRAM, NFS3_VERSION);
+-	if (!status) {
++	if (status == -EHOSTUNREACH) {
++		supported = status;
++		goto done_ver;
++	} else if (!status) {
+ 		gettimeofday(&start, &tz);
+ 		status = rpc_ping_proto(rpc_info);
+ 		gettimeofday(&end, &tz);
+@@ -643,15 +655,23 @@ v2_ver:
+ 		parms.pm_prot = rpc_info->proto->p_proto;
+ 		parms.pm_vers = NFS2_VERSION;
+ 		rpc_info->port = rpc_portmap_getport(pm_info, &parms);
+-		if (rpc_info->port < 0)
++		status = rpc_portmap_getport(pm_info, &parms);
++		if (status == -EHOSTUNREACH) {
++			supported = status;
++			goto done_ver;
++		} else if (status < 0)
+ 			goto done_ver;
++		rpc_info->port = status;
+ 	}
+ 
+ 	if (rpc_info->proto->p_proto == IPPROTO_UDP)
+ 		status = rpc_udp_getclient(rpc_info, NFS_PROGRAM, NFS2_VERSION);
+ 	else
+ 		status = rpc_tcp_getclient(rpc_info, NFS_PROGRAM, NFS2_VERSION);
+-	if (!status) {
++	if (status == -EHOSTUNREACH) {
++		supported = status;
++		goto done_ver;
++	} else if (!status) {
+ 		gettimeofday(&start, &tz);
+ 		status = rpc_ping_proto(rpc_info);
+ 		gettimeofday(&end, &tz);
+@@ -728,21 +748,24 @@ static int get_vers_and_cost(unsigned logopt, struct host *host,
+ 
+ 	vers &= version;
+ 
+-	if (version & UDP_REQUESTED) {
++	if (version & TCP_REQUESTED) {
+ 		supported = get_nfs_info(logopt, host,
+-				   &pm_info, &rpc_info, "udp", vers, options);
+-		if (supported) {
++				   &pm_info, &rpc_info, "tcp", vers, options);
++		if (IS_ERR(supported)) {
++			if (ERR(supported) == EHOSTUNREACH)
++				return ret;
++		} else if (supported) {
+ 			ret = 1;
+-			host->version |= (supported << 8);
++			host->version |= supported;
+ 		}
+ 	}
+ 
+-	if (version & TCP_REQUESTED) {
++	if (version & UDP_REQUESTED) {
+ 		supported = get_nfs_info(logopt, host,
+-				   &pm_info, &rpc_info, "tcp", vers, options);
++				   &pm_info, &rpc_info, "udp", vers, options);
+ 		if (supported) {
+ 			ret = 1;
+-			host->version |= supported;
++			host->version |= (supported << 8);
+ 		}
+ 	}
+ 
+@@ -848,7 +871,9 @@ static int get_supported_ver_and_cost(unsigned logopt, struct host *host,
+ 		status = rpc_udp_getclient(&rpc_info, NFS_PROGRAM, parms.pm_vers);
+ 	else
+ 		status = rpc_tcp_getclient(&rpc_info, NFS_PROGRAM, parms.pm_vers);
+-	if (!status) {
++	if (status == -EHOSTUNREACH)
++		goto done;
++	else if (!status) {
+ 		gettimeofday(&start, &tz);
+ 		status = rpc_ping_proto(&rpc_info);
+ 		gettimeofday(&end, &tz);
Index: backfire/feeds/packages/utils/autofs/patches/134-autofs-5.0.6-systemd-support-fixes.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/134-autofs-5.0.6-systemd-support-fixes.patch
@@ -0,0 +1,110 @@
+autofs-5.0.6 - systemd support fixes
+
+From: Ian Kent <raven@themaw.net>
+
+Fix up some of in spec file systemd scriptlets.
+
+The pre-system package verion uninstall scriptlet has been commented
+out in the tar spec file. It's is an example of what might need to
+be done in a distro spec file.
+---
+
+ CHANGELOG                 |    1 +
+ autofs.spec               |   41 ++++++++++++++++++++++++++++++-----------
+ samples/autofs.service.in |    1 +
+ 3 files changed, 32 insertions(+), 11 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index 69ade49..b9c3149 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -32,6 +32,7 @@
+ - reinstate singleton mount probe.
+ - rework error return handling in rpc code.
+ - catch EHOSTUNREACH and bail out early.
++- systemd support fixes.
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/autofs.spec b/autofs.spec
+index d854b1f..a73fefb 100644
+--- a/autofs.spec
++++ b/autofs.spec
+@@ -105,34 +105,53 @@ install -m 644 redhat/autofs.sysconfig $RPM_BUILD_ROOT/etc/sysconfig/autofs
+ 
+ %post
+ %if %{with_systemd}
+-/bin/systemctl daemon-reload >/dev/null 2>&1 || :
++if [ $1 -eq 1 ]; then
++	%{_bindir}/systemctl daemon-reload >/dev/null 2>&1 || :
++	# autofs has been approved to be enabled by default
++	%{_bindir}/systemctl enable %{name}.service >/dev/null 2>&1 || :
++fi
+ %else
+-chkconfig --add autofs
++if [ $1 -eq 1 ]; then
++	%{_sbindir}/chkconfig --add autofs
++fi
+ %endif
+ 
+ %preun
+-if [ "$1" = 0 ] ; then
+ %if %{with_systemd}
+-	/bin/systemctl --no-reload disable autofs.service > /dev/null 2>&1 || :
+-	/bin/systemctl stop autofs.service > /dev/null 2>&1 || :
++if [ $1 -eq 0 ] ; then
++	%{_bindir}/systemctl --no-reload disable %{name}.service > /dev/null 2>&1 || :
++	%{_bindir}/systemctl stop %{name}.service > /dev/null 2>&1 || :
++fi
+ %else
+-	/sbin/service autofs stop > /dev/null 2>&1 || :
+-	/sbin/chkconfig --del autofs
+-%endif
++if [ $1 -eq 0 ] ; then
++	%{_sbindir}/service autofs stop > /dev/null 2>&1 || :
++	%{_sbindir}/chkconfig --del autofs
+ fi
++%endif
+ 
+ %postun
+ %if %{with_systemd}
+-/bin/systemctl daemon-reload >/dev/null 2>&1 || :
++%{_bindir}/systemctl daemon-reload >/dev/null 2>&1 || :
+ if [ $1 -ge 1 ] ; then
+-	/bin/systemctl try-restart autofs.service >/dev/null 2>&1 || :
++	# Package upgrade, not removal
++	%{_bindir}/systemctl try-restart %{name}.service >/dev/null 2>&1 || :
+ fi
+ %else
+ if [ $1 -ge 1 ] ; then
+-	/sbin/service autofs condrestart > /dev/null 2>&1 || :
++	%{_sbindir}/service autofs condrestart > /dev/null 2>&1 || :
+ fi
+ %endif
+ 
++#%triggerun -- %{name} < $bla release
++## Save the current service runlevel info
++## User must manually run systemd-sysv-convert --apply %{name}
++## to migrate them to systemd targets
++#%{_bindir}/systemd-sysv-convert --save %{name} >/dev/null 2>&1 ||:
++#
++## Run these because the SysV package being removed won't do them
++#%{_sbindir}/chkconfig --del %{name} >/dev/null 2>&1 || :
++#%{_bindir}/systemctl try-restart %{name}.service >/dev/null 2>&1 || :
++
+ %files
+ %defattr(-,root,root)
+ %doc CREDITS CHANGELOG INSTALL COPY* README* samples/ldap* samples/autofs.schema samples/autofs_ldap_auth.conf
+diff --git a/samples/autofs.service.in b/samples/autofs.service.in
+index 3756078..879b47b 100644
+--- a/samples/autofs.service.in
++++ b/samples/autofs.service.in
+@@ -7,6 +7,7 @@ Type=forking
+ PIDFile=@@autofspiddir@@/autofs.pid
+ EnvironmentFile=-@@autofsconfdir@@/autofs
+ ExecStart=@@sbindir@@/automount ${OPTIONS} --pid-file @@autofspiddir@@/autofs.pid
++ExecReload=/usr/bin/kill -HUP $MAINPID
+ 
+ [Install]
+ WantedBy=multi-user.target
Index: backfire/feeds/packages/utils/autofs/patches/135-autofs-5.0.6-fix-segmentation-fault-in-do_remount_indirect.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/135-autofs-5.0.6-fix-segmentation-fault-in-do_remount_indirect.patch
@@ -0,0 +1,90 @@
+autofs-5.0.6 - fix segmentation fault in do_remount_indirect()
+
+From: Leonardo Chiquitto <leonardo.lists@gmail.com>
+
+In some rare circumstance, it's possible that automount will crash
+on startup while trying to reconnect to a "half-broken" NFS mount
+point.
+
+The segmentation fault happens because we're not testing scandir()'s
+return value in do_remount_indirect():
+
+lib/mounts.c:
+1210       i = j = scandir(buf, &de2, 0, alphasort);
+1211       while (i--)
+1212         free(de2[i]);
+
+So, if scandir() returns -1, it will try to free de2[-1], de2[-2], etc.
+
+Here's the call trace, for reference:
+
+Program terminated with signal 11, Segmentation fault.
+#0  0x00007ffff7fe2425 in do_remount_indirect (ap=0x7ffff821e070, fd=15,
+    path=0x7ffff821e150 "/nfs/iil") at mounts.c:1212
+1212                    free(de2[i]);
+(gdb) print j
+$1 = -1
+(gdb) print de2
+$3 = (struct dirent **) 0x0
+
+#0  0x00007ffff7fe2425 in do_remount_indirect (ap=0x7ffff821e070, fd=15,
+    path=0x7ffff821e150 "/nfs/iil") at mounts.c:1212
+#1  0x00007ffff7fe2a48 in remount_active_mount (ap=0x7ffff821e070, mc=0x0,
+    path=0x7ffff821e150 "/nfs/iil", devid=20, type=<optimized out>,
+    ioctlfd=0x7ffff6e5babc) at mounts.c:1327
+#2  0x00007ffff7fe2ac6 in try_remount (ap=0x7ffff821e070, me=0x0, type=1)
+    at mounts.c:1357
+#3  0x00007ffff7fd35e0 in do_mount_autofs_indirect (root=<optimized out>,
+    ap=<optimized out>) at indirect.c:103
+#4  mount_autofs_indirect (ap=0x7ffff821e070, root=0x7ffff8202d50 "/nfs/iil")
+    at indirect.c:213
+#5  0x00007ffff7fd1473 in mount_autofs (root=<optimized out>,
+    ap=<optimized out>) at automount.c:1005
+#6  handle_mounts (arg=0x7fffffffdfd0) at automount.c:1526
+#7  0x00007ffff7b8e5f0 in start_thread (arg=<optimized out>)
+    at pthread_create.c:297
+#8  0x00007ffff6f3187d in clone ()
+    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:112
+#9  0x0000000000000000 in ?? ()
+
+Suggested fix:
+
+Check scandir() return value
+
+In some rare circumstance, it's possible that automount will crash
+on startup while trying to reconnect to a "half-broken" NFS mount
+point.
+---
+
+ CHANGELOG    |    1 +
+ lib/mounts.c |    4 ++++
+ 2 files changed, 5 insertions(+), 0 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index b9c3149..cc458f9 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -33,6 +33,7 @@
+ - rework error return handling in rpc code.
+ - catch EHOSTUNREACH and bail out early.
+ - systemd support fixes.
++- check scandir() return value.
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/lib/mounts.c b/lib/mounts.c
+index efe0438..e218c79 100644
+--- a/lib/mounts.c
++++ b/lib/mounts.c
+@@ -1355,6 +1355,10 @@ static int do_remount_indirect(struct autofs_point *ap, int fd, const char *path
+ 			int i, j;
+ 
+ 			i = j = scandir(buf, &de2, 0, alphasort);
++			if (i < 0) {
++				free(de[n]);
++				continue;
++			}
+ 			while (i--)
+ 				free(de2[i]);
+ 			free(de2);
Index: backfire/feeds/packages/utils/autofs/patches/136-autofs-5.0.6-allow-for-kernel-packet-size-change.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/136-autofs-5.0.6-allow-for-kernel-packet-size-change.patch
@@ -0,0 +1,55 @@
+autofs-5.0.6 - allow for kernel packet size change
+
+From: Ian Kent <raven@themaw.net>
+
+Kernel 3.3.0 has a patch to allow for the original missdesign of
+the autofs v5 kernel packet.
+
+The problem is that while all the structure fields are alligned
+correctly structure allignment on x86-64 causes the packet size
+to be 4 bytes larger than on x86. So when running an x86 binary
+on an x86-64 install the packet size did not match causing user
+space pipe reads to hang.
+---
+
+ CHANGELOG          |    1 +
+ daemon/automount.c |    6 ++++++
+ 2 files changed, 7 insertions(+), 0 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index cc458f9..7abea14 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -34,6 +34,7 @@
+ - catch EHOSTUNREACH and bail out early.
+ - systemd support fixes.
+ - check scandir() return value.
++- allow for kernel packet size change (in kernel 3.3.0+).
+ 
+ 28/06/2011 autofs-5.0.6
+ -----------------------
+diff --git a/daemon/automount.c b/daemon/automount.c
+index 31dd564..e20b603 100644
+--- a/daemon/automount.c
++++ b/daemon/automount.c
+@@ -36,6 +36,7 @@
+ #include <dirent.h>
+ #include <sys/vfs.h>
+ #include <sys/utsname.h>
++#include "mounts.h"
+ 
+ #include "automount.h"
+ #if defined(LIBXML2_WORKAROUND) || defined(TIRPC_WORKAROUND)
+@@ -598,6 +599,11 @@ static size_t get_kpkt_len(void)
+ {
+ 	size_t pkt_len = sizeof(struct autofs_v5_packet);
+ 	struct utsname un;
++	int kern_vers;
++
++	kern_vers = linux_version_code();
++	if (kernel_vers >= KERNEL_VERSION(3, 3, 0))
++		return pkt_len;
+ 
+ 	uname(&un);
+ 
Index: backfire/feeds/packages/utils/autofs/patches/137-autofs-5.0.6-fix-allow-for-kernel-packet-size-change.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/137-autofs-5.0.6-fix-allow-for-kernel-packet-size-change.patch
@@ -0,0 +1,32 @@
+autofs-5.0.6 - fix allow for kernel packet size change
+
+From: Ian Kent <raven@themaw.net>
+
+Fix a couple of stupid mistakes.
+---
+
+ daemon/automount.c |    3 +--
+ 1 files changed, 1 insertions(+), 2 deletions(-)
+
+
+diff --git a/daemon/automount.c b/daemon/automount.c
+index e20b603..0ff3c96 100644
+--- a/daemon/automount.c
++++ b/daemon/automount.c
+@@ -36,7 +36,6 @@
+ #include <dirent.h>
+ #include <sys/vfs.h>
+ #include <sys/utsname.h>
+-#include "mounts.h"
+ 
+ #include "automount.h"
+ #if defined(LIBXML2_WORKAROUND) || defined(TIRPC_WORKAROUND)
+@@ -602,7 +601,7 @@ static size_t get_kpkt_len(void)
+ 	int kern_vers;
+ 
+ 	kern_vers = linux_version_code();
+-	if (kernel_vers >= KERNEL_VERSION(3, 3, 0))
++	if (kern_vers >= KERNEL_VERSION(3, 3, 0))
+ 		return pkt_len;
+ 
+ 	uname(&un);
Index: backfire/feeds/packages/utils/autofs/patches/200-fix-configure-not-run-when-cross-compiling
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/200-fix-configure-not-run-when-cross-compiling
@@ -0,0 +1,11 @@
+--- a/configure.in	2012-02-28 14:49:36.000000000 +0800
++++ b/configure.in	2012-02-28 14:52:03.000000000 +0800
+@@ -306,7 +306,7 @@
+ DAEMON_CFLAGS=
+ DAEMON_LDFLAGS=
+ AC_MSG_CHECKING([whether gcc -fPIE works])
+-AC_RUN_IFELSE([AC_LANG_PROGRAM([[]], [[int main(void) {return 0;}]])],
++AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]], [[int main(void) {return 0;}]])],
+ 	      [gcc_supports_pie=yes], [gcc_supports_pie=no])
+ AC_MSG_RESULT([$gcc_supports_pie])
+ if test $gcc_supports_pie = yes ; then
Index: backfire/feeds/packages/utils/autofs/patches/202-disable-yp-lookup
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/202-disable-yp-lookup
@@ -0,0 +1,34 @@
+--- a/lib/Makefile	2011-06-28 15:34:35.000000000 +0800
++++ b/lib/Makefile	2012-02-28 16:10:33.000000000 +0800
+@@ -10,7 +10,7 @@
+ 	args.c alarm.c macros.c master.c defaults.c parse_subs.c \
+ 	dev-ioctl-lib.c
+ RPCS = mount.h mount_clnt.c mount_xdr.c
+-OBJS = cache.o mount_clnt.o mount_xdr.o cat_path.o rpc_subs.o \
++OBJS = cache.o mount_clnt.o mount_xdr.o cat_path.o \
+ 	mounts.o log.o nsswitch.o master_tok.o master_parse.tab.o \
+ 	nss_tok.o nss_parse.tab.o args.o alarm.o macros.o master.o \
+ 	defaults.o parse_subs.o dev-ioctl-lib.o
+--- a/modules/Makefile	2012-02-28 15:45:19.000000000 +0800
++++ b/modules/Makefile	2012-02-28 16:16:47.000000000 +0800
+@@ -11,7 +11,7 @@
+ 	mount_generic.c  mount_nfs.c  mount_afs.c  mount_autofs.c \
+ 	mount_changer.c  mount_bind.c
+ 
+-MODS :=	lookup_yp.so lookup_file.so lookup_program.so lookup_userhome.so \
++MODS :=	lookup_file.so lookup_program.so lookup_userhome.so \
+ 	lookup_multi.so lookup_hosts.so lookup_dir.so \
+ 	parse_sun.so \
+ 	mount_generic.so mount_nfs.so mount_afs.so mount_autofs.so \
+--- a/daemon/lookup.c	2012-02-28 16:49:08.000000000 +0800
++++ b/daemon/lookup.c	2012-02-28 17:27:27.000000000 +0800
+@@ -172,9 +172,6 @@
+ 
+ 			memset(source, 0, 10);
+ 			if (!strncmp(name, "file:", 5) ||
+-			    !strncmp(name, "yp:", 3) ||
+-			    !strncmp(name, "nis:", 4) ||
+-			    !strncmp(name, "nisplus:", 8) ||
+ 			    !strncmp(name, "ldap:", 5) ||
+ 			    !strncmp(name, "ldaps:", 6) ||
+ 			    !strncmp(name, "sss:", 4) ||
Index: backfire/feeds/packages/utils/autofs/patches/203-disable-ldap-code-in-defaults
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/203-disable-ldap-code-in-defaults
@@ -0,0 +1,46 @@
+--- a/lib/defaults.c	2011-06-28 15:34:35.000000000 +0800
++++ b/lib/defaults.c	2012-02-28 16:46:53.000000000 +0800
+@@ -19,7 +19,9 @@
+ 
+ #include "list.h"
+ #include "defaults.h"
++#ifdef WITH_LDAP
+ #include "lookup_ldap.h"
++#endif
+ #include "log.h"
+ #include "automount.h"
+ 
+@@ -197,6 +199,8 @@
+ 	return 1;
+ }
+ 
++#ifdef WITH_LDAP
++
+ void defaults_free_uris(struct list_head *list)
+ {
+ 	struct list_head *next;
+@@ -290,6 +294,8 @@
+ 	return list;
+ }
+ 
++#endif
++
+ /*
+  * Read config env variables and check they have been set.
+  *
+@@ -428,6 +434,7 @@
+ 	return logging;
+ }
+ 
++#ifdef WITH_LDAP
+ unsigned int defaults_get_ldap_timeout(void)
+ {
+ 	int res;
+@@ -645,6 +652,7 @@
+ 
+ 	return schema;
+ }
++#endif
+ 
+ unsigned int defaults_get_mount_nfs_default_proto(void)
+ {
Index: backfire/feeds/packages/utils/autofs/patches/205-fix-install-symlinks
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/205-fix-install-symlinks
@@ -0,0 +1,13 @@
+--- a/modules/Makefile	2012-02-28 21:54:53.000000000 +0800
++++ b/modules/Makefile	2012-02-28 22:04:49.000000000 +0800
+@@ -68,8 +68,9 @@
+ 	install -c $(MODS) -m 755 $(INSTALLROOT)$(autofslibdir)
+ 	-rm -f $(INSTALLROOT)$(autofslibdir)/mount_smbfs.so
+ 	ln -fs lookup_file.so $(INSTALLROOT)$(autofslibdir)/lookup_files.so
+-	ln -fs lookup_yp.so $(INSTALLROOT)$(autofslibdir)/lookup_nis.so
++ifeq ($(LDAP), 1)
+ 	ln -fs lookup_ldap.so $(INSTALLROOT)$(autofslibdir)/lookup_ldaps.so
++endif
+ 	ln -fs mount_nfs.so $(INSTALLROOT)$(autofslibdir)/mount_nfs4.so
+ ifeq ($(EXT2FS), 1)
+  ifeq ($(EXT3FS), 1)
Index: backfire/feeds/packages/utils/autofs/patches/201-uclibc-compat
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/201-uclibc-compat
@@ -0,0 +1,38 @@
+--- a/include/rpc_subs.h	2011-06-28 15:34:35.000000000 +0800
++++ b/include/rpc_subs.h	2012-02-28 15:42:51.000000000 +0800
+@@ -18,7 +18,7 @@
+ 
+ #include <rpc/rpc.h>
+ #include <rpc/pmap_prot.h>
+-#include <nfs/nfs.h>
++#include <linux/nfs.h>
+ #include <linux/nfs2.h>
+ #include <linux/nfs3.h>
+ 
+--- a/modules/lookup_dir.c	2012-02-28 17:08:29.000000000 +0800
++++ b/modules/lookup_dir.c	2012-02-28 16:56:54.000000000 +0800
+@@ -39,6 +39,13 @@
+ #define AUTOFS_DIR_EXT ".autofs"
+ #define AUTOFS_DIR_EXTSIZ (sizeof(AUTOFS_DIR_EXT) - 1)
+ 
++static int
++versionsort (const void *a, const void *b)
++{
++  return __strverscmp ((*(const struct dirent **) a)->d_name,
++               (*(const struct dirent **) b)->d_name);
++}
++
+ struct lookup_context {
+   const char *mapname;
+ };
+--- a/modules/replicated.c	2012-02-28 16:49:08.000000000 +0800
++++ b/modules/replicated.c	2012-02-28 17:12:34.000000000 +0800
+@@ -1223,7 +1223,7 @@
+ 				rr4++;
+ 		} else if (this->ai_family == AF_INET6) {
+ 			struct sockaddr_in6 *addr = (struct sockaddr_in6 *) this->ai_addr;
+-			if (!IN6_IS_ADDR_LOOPBACK(addr->sin6_addr.__in6_u.__u6_addr32))
++			if (!IN6_IS_ADDR_LOOPBACK(addr->sin6_addr.in6_u.u6_addr32))
+ 				rr6++;
+ 		}
+ 		this = this->ai_next;
Index: backfire/feeds/packages/utils/autofs/files/autofs.init
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/files/autofs.init
@@ -0,0 +1,88 @@
+#!/bin/sh /etc/rc.common
+#
+# Author: Zhifeng Gu <guzhifeng1979@hotmail.com>
+# Date: 2012/03
+# License: GPL
+
+START=21
+STOP=98
+
+MASTER_FILE=/tmp/auto.master
+AUTOMOUNT_OPTS=
+
+. /lib/functions/autofs.sh
+
+create_map_entry() {
+    local cfg="$1"
+    local entry type maptype mountpoint map timeout
+
+    config_get type "$cfg" type
+    case "$type" in
+        direct)
+            mountpoint=/-
+            ;;
+        indirect)
+            config_get mountpoint "$cfg" mountpoint
+            ;;
+        *)
+            logger -t "autofs" "unknown map type: $type"
+            return
+    esac
+
+    config_get maptype "$cfg" maptype
+    config_get map "$cfg" map
+
+    entry="$mountpoint\t\t$maptype:$map"
+
+    config_get timeout "$cfg" timeout
+    if [ -n "$timeout" ]; then
+        entry="$entry\t\t-DTIMEOUT=$timeout"
+    fi
+
+    echo -e $entry >> $MASTER_FILE
+}
+
+automount_options() {
+    local cfg="$1"
+    local timeout
+
+    config_get timeout "$cfg" timeout
+    if [ -n "$timeout" ]; then
+        AUTOMOUNT_OPTS="$AUTOMOUNT_OPTS -t $timeout"
+    fi
+}
+
+start_daemon() {
+    . /etc/functions.sh
+
+    config_load autofs
+    echo "# Auto generated map entries, please modify /etc/config/autofs." > $MASTER_FILE
+    config_foreach create_map_entry mapentry
+    config_foreach automount_options automount
+    automount -p $AUTOMOUNT_PIDFILE $AUTOMOUNT_OPTS
+}
+
+start() {
+    if is_running; then
+        logger -t "autofs" "automount is already running"
+        return
+    fi
+    start_daemon
+}
+
+stop() {
+    if ! is_running; then
+        return
+    fi
+    kill -TERM `cat $AUTOMOUNT_PIDFILE`
+    rm -f $AUTOMOUNT_PIDFILE
+    echo "# Autofs is stopped" > $MASTER_FILE
+}
+
+restart() {
+    if is_running; then
+        reload_config
+    else
+        start_daemon
+    fi
+}
Index: backfire/feeds/packages/utils/autofs/files/50-autofs
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/files/50-autofs
@@ -0,0 +1,13 @@
+#!/bin/sh
+# Author: Zhifeng Gu <guzhifeng1979@hotmail.com>
+# Date: 2012/03
+# License: GPL
+
+blkdev=`dirname $DEVPATH`
+
+if [ `basename $blkdev` != "block" ]; then
+    . /lib/functions/autofs.sh
+    if is_running; then
+        reload_config
+    fi
+fi
Index: backfire/feeds/packages/utils/autofs/files/autofs.conf
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/files/autofs.conf
@@ -0,0 +1,13 @@
+config automount
+       option timeout   60
+
+config mapentry
+       option type      direct
+       option maptype   file
+       option map       /lib/functions/autofs/direct.fstab
+
+#config mapentry
+#       option type         indirect
+#       option mountpoint   /home
+#       option maptype      file
+#       option map          /etc/auto.home
Index: backfire/feeds/packages/utils/autofs/files/direct.fstab
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/files/direct.fstab
@@ -0,0 +1,49 @@
+#!/bin/sh
+# Author: Zhifeng Gu <guzhifeng1979@hotmail.com>
+# Date: 2012/03
+# License: GPL
+
+. /etc/functions.sh
+
+direct_mount() {
+    local cfg="$1"
+    local is_rootfs target uuid device label fstype options enabled
+
+    # ignore rootfs targets
+    config_get_bool is_rootfs "$cfg" is_rootfs 0
+    if [ "is_rootfs" = 1 ]; then
+        return
+    fi
+    config_get target "$cfg" target
+    if [ -z "$target" ] || [ "$target" = / ] || [ "$target" = /overlay ]; then
+        return
+    fi
+    # ignore enabled mount entries
+    config_get_bool enabled "$cfg" enabled 1
+    if [ "$enabled" = 1 ]; then
+        return
+    fi
+
+    config_get device "$cfg" device
+    config_get label "$cfg" label
+    config_get uuid "$cfg" uuid
+    if [ -n "$uuid" ] && blkid | grep -q UUID=\"$uuid\"; then
+        device="UUID=$uuid"
+    elif [ -n "$label" ] && blkid | grep -q LABEL=\"$label\"; then
+        device="LABEL=$label"
+    elif [ -z "$device" ] || ! blkid | grep -q ^$device; then
+        return
+    fi
+
+    config_get fstype "$cfg" fstype "auto"
+    config_get options "$cfg" options
+    if [ -z "$options" ]; then
+        options="-fstype=$fstype"
+    else
+        options="-fstype=$fstype,$options"
+    fi
+    echo -e "$target\t\t$options\t\t:$device"
+}
+
+config_load fstab
+config_foreach direct_mount mount
Index: backfire/feeds/packages/utils/autofs/patches/206-disable-parsing-nsswitch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/206-disable-parsing-nsswitch
@@ -0,0 +1,33 @@
+--- a/lib/nsswitch.c	2011-06-28 15:34:35.000000000 +0800
++++ b/lib/nsswitch.c	2012-03-04 00:03:06.000000000 +0800
+@@ -105,6 +105,12 @@
+ 	return 1;
+ }
+ 
++int nsswitch_parse(struct list_head *list)
++{
++    return add_source(list, "files") ? 0 : 1;
++}
++
++
+ /*
+ int main(void)
+ {
+--- a/lib/Makefile	2012-03-02 23:47:09.000000000 +0800
++++ b/lib/Makefile	2012-03-04 00:02:11.000000000 +0800
+@@ -6,13 +6,13 @@
+ include ../Makefile.rules
+ 
+ SRCS = cache.c cat_path.c rpc_subs.c mounts.c log.c nsswitch.c \
+-	master_tok.l master_parse.y nss_tok.c nss_parse.tab.c \
++	master_tok.l master_parse.y \
+ 	args.c alarm.c macros.c master.c defaults.c parse_subs.c \
+ 	dev-ioctl-lib.c
+ RPCS = mount.h mount_clnt.c mount_xdr.c
+ OBJS = cache.o mount_clnt.o mount_xdr.o cat_path.o \
+ 	mounts.o log.o nsswitch.o master_tok.o master_parse.tab.o \
+-	nss_tok.o nss_parse.tab.o args.o alarm.o macros.o master.o \
++	args.o alarm.o macros.o master.o \
+ 	defaults.o parse_subs.o dev-ioctl-lib.o
+ 
+ YACCSRC = nss_tok.c nss_parse.tab.c nss_parse.tab.h \
Index: backfire/feeds/packages/utils/autofs/patches/207-make-runtime-dep-commands-configurable
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/207-make-runtime-dep-commands-configurable
@@ -0,0 +1,60 @@
+--- a/aclocal.m4	2012-03-06 10:07:08.000000000 +0800
++++ b/aclocal.m4	2012-03-06 10:21:34.000000000 +0800
+@@ -5,15 +5,22 @@
+ dnl Like AC_PATH_PROGS, but add to the .h file as well
+ dnl --------------------------------------------------------------------------
+ AC_DEFUN(AF_PATH_INCLUDE,
+-[AC_PATH_PROGS($1,$2,$3,$4)
+-if test -n "$$1"; then
+-  AC_DEFINE(HAVE_$1,1,[define if you have $1])
+-  AC_DEFINE_UNQUOTED(PATH_$1, "$$1", [define if you have $1])
++[ 
++  $1="$2"
++  AC_ARG_WITH($1,
++  [  --with-$1=PATH	  override the default value with PATH ],
++	 if test -n "$withval"
++     then
++       $1="${withval}"
++     fi
++  )
++  AC_MSG_CHECKING([for $1 executable])
++  AC_MSG_RESULT([$$1])
++
++  AC_DEFINE(HAVE_$1,1,[define $1])
++  AC_DEFINE_UNQUOTED(PATH_$1, "$$1", [define $1])
+   HAVE_$1=1
+-else
+-  HAVE_$1=0
+-fi
+-AC_SUBST(HAVE_$1)])
++  AC_SUBST(HAVE_$1)])
+ 
+ dnl --------------------------------------------------------------------------
+ dnl AF_CHECK_PROG:
+--- a/configure.in	2012-03-06 10:07:08.000000000 +0800
++++ b/configure.in	2012-03-06 10:24:39.000000000 +0800
+@@ -136,13 +136,17 @@
+ #
+ # Programs needed for various system functions or modules
+ #
+-AF_PATH_INCLUDE(MOUNT, mount, /bin/mount, $searchpath)
+-AF_PATH_INCLUDE(MOUNT_NFS, mount.nfs, /sbin/mount.nfs , $searchpath)
+-AF_PATH_INCLUDE(UMOUNT, umount, /bin/umount, $searchpath)
+-AF_PATH_INCLUDE(E2FSCK, fsck.ext2 e2fsck, , $searchpath)
+-AF_PATH_INCLUDE(E3FSCK, fsck.ext3 e3fsck, , $searchpath)
+-AF_PATH_INCLUDE(E4FSCK, fsck.ext4 e4fsck, , $searchpath)
+-AF_PATH_INCLUDE(MODPROBE, modprobe, , $searchpath)
++
++#
++# Location of system config script directory?
++#
++AF_PATH_INCLUDE(MOUNT, /bin/mount)
++AF_PATH_INCLUDE(MOUNT_NFS, /sbin/mount.nfs)
++AF_PATH_INCLUDE(UMOUNT, /bin/umount)
++AF_PATH_INCLUDE(E2FSCK, /sbin/fsck.ext2)
++AF_PATH_INCLUDE(E3FSCK, /sbin/fsck.ext3)
++AF_PATH_INCLUDE(E4FSCK, /sbin/fsck.ext4)
++AF_PATH_INCLUDE(MODPROBE, /sbin/modprobe)
+ 
+ AF_CHECK_PROG(LEX, flex lex, , $searchpath)
+ AF_CHECK_PROG(YACC, bison, , $searchpath)
Index: backfire/feeds/packages/utils/autofs/patches/208-dynamic-lookup-file
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/208-dynamic-lookup-file
@@ -0,0 +1,95 @@
+Index: b/modules/lookup_file.c
+===================================================================
+--- a/modules/lookup_file.c
++++ b/modules/lookup_file.c
+@@ -49,6 +49,54 @@
+ 
+ int lookup_version = AUTOFS_LOOKUP_VERSION;	/* Required by protocol */
+ 
++static FILE *open_fopen_r_dyn(const char *path)
++{
++    FILE  *f;
++    pid_t pid;
++    int   pipefd[2];
++    
++    if (!access(path, X_OK)) {
++        debug(LOGOPT_NONE, "%s is executable, load it as dynamic file", path);
++
++        // execute the file and pipe the stdout
++        if (pipe(pipefd)) {
++            logerr(MODPREFIX "fail to create pipe");
++            return NULL;
++        }
++
++        pid = fork();
++        if (pid < 0) {
++            logerr(MODPREFIX "fork error");
++            return NULL;
++        }
++
++        if (pid == 0) { // execute the file
++            close(pipefd[0]);
++            dup2(pipefd[1], STDOUT_FILENO);
++            close(pipefd[1]);
++            execl(path, path, NULL);
++            logerr(MODPREFIX "fail to execute %s", path);
++            exit(255);	/* execl() failed */
++        }
++
++        // wrap the pipe read endpoint, and return
++        close(pipefd[1]);
++        f = fdopen(pipefd[0], "r");
++    }
++    else
++        f = fopen(path, "r");
++
++    if (f == NULL) {
++        logerr(MODPREFIX "open file error: %s", strerror(errno));
++        return NULL;
++    }
++#if defined(O_CLOEXEC) && defined(SOCK_CLOEXEC)
++    check_cloexec(fileno(f));
++#endif
++    return f;
++}
++
++
+ int lookup_init(const char *mapfmt, int argc, const char *const *argv, void **context)
+ {
+ 	struct lookup_context *ctxt;
+@@ -393,7 +441,7 @@
+ 		return NSS_STATUS_UNAVAIL;
+ 	}
+ 
+-	f = open_fopen_r(ctxt->mapname);
++	f = open_fopen_r_dyn(ctxt->mapname);
+ 	if (!f) {
+ 		error(logopt,
+ 		      MODPREFIX "could not open master map file %s",
+@@ -609,7 +657,7 @@
+ 		return NSS_STATUS_UNAVAIL;
+ 	}
+ 
+-	f = open_fopen_r(ctxt->mapname);
++	f = open_fopen_r_dyn(ctxt->mapname);
+ 	if (!f) {
+ 		error(ap->logopt,
+ 		      MODPREFIX "could not open map file %s", ctxt->mapname);
+@@ -702,7 +750,7 @@
+ 
+ 	mc = source->mc;
+ 
+-	f = open_fopen_r(ctxt->mapname);
++	f = open_fopen_r_dyn(ctxt->mapname);
+ 	if (!f) {
+ 		error(ap->logopt,
+ 		      MODPREFIX "could not open map file %s", ctxt->mapname);
+@@ -807,7 +855,7 @@
+ 
+ 	mc = source->mc;
+ 
+-	f = open_fopen_r(ctxt->mapname);
++	f = open_fopen_r_dyn(ctxt->mapname);
+ 	if (!f) {
+ 		error(ap->logopt,
+ 		      MODPREFIX "could not open map file %s", ctxt->mapname);
Index: backfire/feeds/packages/utils/autofs/files/autofs.sh
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/files/autofs.sh
@@ -0,0 +1,19 @@
+#!/bin/sh
+#
+# Author: Zhifeng Gu <guzhifeng1979@hotmail.com>
+# Date: 2012/03
+# License: GPL
+
+AUTOMOUNT_PIDFILE=/var/run/automount.pid
+
+is_running() {
+    if [ ! -e $AUTOMOUNT_PIDFILE ]; then
+        return 1
+    fi
+    ps -p `cat $AUTOMOUNT_PIDFILE` &> /dev/null
+    return $?
+}
+
+reload_config() {
+    kill -HUP `cat $AUTOMOUNT_PIDFILE`
+}
